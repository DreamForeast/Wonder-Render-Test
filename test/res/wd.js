(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.wd = {})));
}(this, (function (exports) { 'use strict';

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var stateData = /* record */[
	  /* state : None */0,
	  /* isTest : false */0
	];


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getOptionValueFromJsObj(valueFromJsObj) {
	  if (valueFromJsObj == null) {
	    return /* None */0;
	  } else {
	    return [valueFromJsObj];
	  }
	}

	function getValueFromJsObj(valueFromJsObj, defaultValue) {
	  if (valueFromJsObj == null) {
	    return defaultValue;
	  } else {
	    return valueFromJsObj;
	  }
	}


	/* No side effect */

	function isSome(param) {
	  if (param) {
	    return /* true */1;
	  } else {
	    return /* false */0;
	  }
	}

	function isNone(param) {
	  if (param) {
	    return /* false */0;
	  } else {
	    return /* true */1;
	  }
	}

	function getExn(x) {
	  if (x) {
	    return x[0];
	  } else {
	    throw new Error("Bs_option.getExn");
	  }
	}


	/* No side effect */

	function to_js_boolean(b) {
	  if (b) {
	    return true;
	  } else {
	    return false;
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function setCanvas(canvas, state) {
	  var newrecord = state.slice();
	  var init = state[/* viewData */7];
	  newrecord[/* viewData */7] = /* record */[
	    /* canvas : Some */[canvas],
	    /* contextConfig */init[/* contextConfig */1]
	  ];
	  return newrecord;
	}

	function setContextConfig(contextConfig, state) {
	  var newrecord = state.slice();
	  var init = state[/* viewData */7];
	  newrecord[/* viewData */7] = /* record */[
	    /* canvas */init[/* canvas */0],
	    /* contextConfig : Some */[contextConfig]
	  ];
	  return newrecord;
	}

	function _convertContextConfigDataToJsObj(param) {
	  return {
	          alpha: to_js_boolean(param[/* alpha */0]),
	          depth: to_js_boolean(param[/* depth */1]),
	          stencil: to_js_boolean(param[/* stencil */2]),
	          antialias: to_js_boolean(param[/* antialias */3]),
	          premultipliedAlpha: to_js_boolean(param[/* premultipliedAlpha */4]),
	          preserveDrawingBuffer: to_js_boolean(param[/* preserveDrawingBuffer */5])
	        };
	}

	function getContext(canvas, options) {
	  return canvas.getContext("webgl", _convertContextConfigDataToJsObj(options));
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGpuDetectData(state) {
	  return state[/* gpuDetectData */4];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _getExtension(name, gl) {
	  var tmp = name === "instanced_arrays" ? gl.getExtension("ANGLE_instanced_arrays") : gl.getExtension(name);
	  if (tmp == null) {
	    return /* None */0;
	  } else {
	    return [tmp];
	  }
	}

	function _detectExtension(gl, gpuDetectData) {
	  return /* record */[
	          /* extensionInstancedArrays */_getExtension("instanced_arrays", gl),
	          /* precision */gpuDetectData[/* precision */1]
	        ];
	}

	function _detectPrecision(gl, gpuDetectData) {
	  var vertexShader = gl.VERTEX_SHADER;
	  var fragmentShader = gl.FRAGMENT_SHADER;
	  var highFloat = gl.HIGH_FLOAT;
	  var mediumFloat = gl.MEDIUM_FLOAT;
	  var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(vertexShader, highFloat);
	  var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(vertexShader, mediumFloat);
	  var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(fragmentShader, highFloat);
	  var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(fragmentShader, mediumFloat);
	  var highpAvailable = +(vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0);
	  var mediumpAvailable = +(vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0);
	  if (highpAvailable) {
	    return /* record */[
	            /* extensionInstancedArrays */gpuDetectData[/* extensionInstancedArrays */0],
	            /* precision : Some */[/* HIGHP */0]
	          ];
	  } else if (mediumpAvailable) {
	    console.warn("not support highp, using mediump instead");
	    return /* record */[
	            /* extensionInstancedArrays */gpuDetectData[/* extensionInstancedArrays */0],
	            /* precision : Some */[/* MEDIUMP */1]
	          ];
	  } else {
	    console.warn("not support highp and mediump, using lowp instead");
	    return /* record */[
	            /* extensionInstancedArrays */gpuDetectData[/* extensionInstancedArrays */0],
	            /* precision : Some */[/* LOWP */2]
	          ];
	  }
	}

	function detect(gl, state) {
	  var newrecord = state.slice();
	  newrecord[/* gpuDetectData */4] = _detectPrecision(gl, _detectExtension(gl, getGpuDetectData(state)));
	  return newrecord;
	}

	var hasExtension = isSome;


	/* No side effect */

	var out_of_memory = /* tuple */[
	  "Out_of_memory",
	  0
	];

	var sys_error = /* tuple */[
	  "Sys_error",
	  -1
	];

	var failure = /* tuple */[
	  "Failure",
	  -2
	];

	var invalid_argument = /* tuple */[
	  "Invalid_argument",
	  -3
	];

	var end_of_file = /* tuple */[
	  "End_of_file",
	  -4
	];

	var division_by_zero = /* tuple */[
	  "Division_by_zero",
	  -5
	];

	var not_found = /* tuple */[
	  "Not_found",
	  -6
	];

	var match_failure = /* tuple */[
	  "Match_failure",
	  -7
	];

	var stack_overflow = /* tuple */[
	  "Stack_overflow",
	  -8
	];

	var sys_blocked_io = /* tuple */[
	  "Sys_blocked_io",
	  -9
	];

	var assert_failure = /* tuple */[
	  "Assert_failure",
	  -10
	];

	var undefined_recursive_module = /* tuple */[
	  "Undefined_recursive_module",
	  -11
	];

	out_of_memory.tag = 248;

	sys_error.tag = 248;

	failure.tag = 248;

	invalid_argument.tag = 248;

	end_of_file.tag = 248;

	division_by_zero.tag = 248;

	not_found.tag = 248;

	match_failure.tag = 248;

	stack_overflow.tag = 248;

	sys_blocked_io.tag = 248;

	assert_failure.tag = 248;

	undefined_recursive_module.tag = 248;


	/*  Not a pure module */

	function caml_array_sub(x, offset, len) {
	  var result = new Array(len);
	  var j = 0;
	  var i = offset;
	  while(j < len) {
	    result[j] = x[i];
	    j = j + 1 | 0;
	    i = i + 1 | 0;
	  }
	  return result;
	}

	function caml_array_get(xs, index) {
	  if (index < 0 || index >= xs.length) {
	    throw [
	          invalid_argument,
	          "index out of bounds"
	        ];
	  } else {
	    return xs[index];
	  }
	}


	/* No side effect */

	function app(_f, _args) {
	  while(true) {
	    var args = _args;
	    var f = _f;
	    var arity = f.length;
	    var arity$1 = arity ? arity : 1;
	    var len = args.length;
	    var d = arity$1 - len | 0;
	    if (d) {
	      if (d < 0) {
	        _args = caml_array_sub(args, arity$1, -d | 0);
	        _f = f.apply(null, caml_array_sub(args, 0, arity$1));
	        continue ;
	        
	      } else {
	        return (function(f,args){
	        return function (x) {
	          return app(f, args.concat(/* array */[x]));
	        }
	        }(f,args));
	      }
	    } else {
	      return f.apply(null, args);
	    }
	  }
	}

	function curry_1(o, a0, arity) {
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[a0]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          return o(a0);
	      case 2 : 
	          return (function (param) {
	              return o(a0, param);
	            });
	      case 3 : 
	          return (function (param, param$1) {
	              return o(a0, param, param$1);
	            });
	      case 4 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, param, param$1, param$2);
	            });
	      case 5 : 
	          return (function (param, param$1, param$2, param$3) {
	              return o(a0, param, param$1, param$2, param$3);
	            });
	      case 6 : 
	          return (function (param, param$1, param$2, param$3, param$4) {
	              return o(a0, param, param$1, param$2, param$3, param$4);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2, param$3, param$4, param$5) {
	              return o(a0, param, param$1, param$2, param$3, param$4, param$5);
	            });
	      
	    }
	  }
	}

	function _1(o, a0) {
	  var arity = o.length;
	  if (arity === 1) {
	    return o(a0);
	  } else {
	    return curry_1(o, a0, arity);
	  }
	}

	function __1(o) {
	  var arity = o.length;
	  if (arity === 1) {
	    return o;
	  } else {
	    return (function (a0) {
	        return _1(o, a0);
	      });
	  }
	}

	function curry_2(o, a0, a1, arity) {
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          return app(o(a0), /* array */[a1]);
	      case 2 : 
	          return o(a0, a1);
	      case 3 : 
	          return (function (param) {
	              return o(a0, a1, param);
	            });
	      case 4 : 
	          return (function (param, param$1) {
	              return o(a0, a1, param, param$1);
	            });
	      case 5 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, a1, param, param$1, param$2);
	            });
	      case 6 : 
	          return (function (param, param$1, param$2, param$3) {
	              return o(a0, a1, param, param$1, param$2, param$3);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2, param$3, param$4) {
	              return o(a0, a1, param, param$1, param$2, param$3, param$4);
	            });
	      
	    }
	  }
	}

	function _2(o, a0, a1) {
	  var arity = o.length;
	  if (arity === 2) {
	    return o(a0, a1);
	  } else {
	    return curry_2(o, a0, a1, arity);
	  }
	}

	function curry_3(o, a0, a1, a2, arity) {
	  var exit = 0;
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1,
	                a2
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          exit = 1;
	          break;
	      case 2 : 
	          return app(o(a0, a1), /* array */[a2]);
	      case 3 : 
	          return o(a0, a1, a2);
	      case 4 : 
	          return (function (param) {
	              return o(a0, a1, a2, param);
	            });
	      case 5 : 
	          return (function (param, param$1) {
	              return o(a0, a1, a2, param, param$1);
	            });
	      case 6 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, a1, a2, param, param$1, param$2);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2, param$3) {
	              return o(a0, a1, a2, param, param$1, param$2, param$3);
	            });
	      
	    }
	  }
	  if (exit === 1) {
	    return app(o(a0), /* array */[
	                a1,
	                a2
	              ]);
	  }
	  
	}

	function _3(o, a0, a1, a2) {
	  var arity = o.length;
	  if (arity === 3) {
	    return o(a0, a1, a2);
	  } else {
	    return curry_3(o, a0, a1, a2, arity);
	  }
	}


	/* No side effect */

	var id = [0];

	function get_id() {
	  id[0] += 1;
	  return id[0];
	}

	function create$1(str) {
	  var v_001 = get_id(/* () */0);
	  var v = /* tuple */[
	    str,
	    v_001
	  ];
	  v.tag = 248;
	  return v;
	}

	function isCamlExceptionOrOpenVariant(e) {
	  if (e === undefined) {
	    return /* false */0;
	  } else if (e.tag === 248) {
	    return /* true */1;
	  } else {
	    var slot = e[0];
	    if (slot !== undefined) {
	      return +(slot.tag === 248);
	    } else {
	      return /* false */0;
	    }
	  }
	}


	/* No side effect */

	var $$Error = create$1("Js_exn.Error");

	function internalToOCamlException(e) {
	  if (isCamlExceptionOrOpenVariant(e)) {
	    return e;
	  } else {
	    return [
	            $$Error,
	            e
	          ];
	  }
	}


	/* No side effect */

	/* No side effect */

	function caml_int_compare(x, y) {
	  if (x < y) {
	    return -1;
	  } else if (x === y) {
	    return 0;
	  } else {
	    return 1;
	  }
	}

	function caml_compare(_a, _b) {
	  while(true) {
	    var b = _b;
	    var a = _a;
	    if (a === b) {
	      return 0;
	    } else {
	      var a_type = typeof a;
	      var b_type = typeof b;
	      if (a_type === "string") {
	        var x = a;
	        var y = b;
	        if (x < y) {
	          return -1;
	        } else if (x === y) {
	          return 0;
	        } else {
	          return 1;
	        }
	      } else {
	        var is_a_number = +(a_type === "number");
	        var is_b_number = +(b_type === "number");
	        if (is_a_number !== 0) {
	          if (is_b_number !== 0) {
	            return caml_int_compare(a, b);
	          } else {
	            return -1;
	          }
	        } else if (is_b_number !== 0) {
	          return 1;
	        } else if (a_type === "boolean" || a_type === "undefined" || a === null) {
	          var x$1 = a;
	          var y$1 = b;
	          if (x$1 === y$1) {
	            return 0;
	          } else if (x$1 < y$1) {
	            return -1;
	          } else {
	            return 1;
	          }
	        } else if (a_type === "function" || b_type === "function") {
	          throw [
	                invalid_argument,
	                "compare: functional value"
	              ];
	        } else {
	          var tag_a = a.tag | 0;
	          var tag_b = b.tag | 0;
	          if (tag_a === 250) {
	            _a = a[0];
	            continue ;
	            
	          } else if (tag_b === 250) {
	            _b = b[0];
	            continue ;
	            
	          } else if (tag_a === 248) {
	            return caml_int_compare(a[1], b[1]);
	          } else if (tag_a === 251) {
	            throw [
	                  invalid_argument,
	                  "equal: abstract value"
	                ];
	          } else if (tag_a !== tag_b) {
	            if (tag_a < tag_b) {
	              return -1;
	            } else {
	              return 1;
	            }
	          } else {
	            var len_a = a.length | 0;
	            var len_b = b.length | 0;
	            if (len_a === len_b) {
	              var a$1 = a;
	              var b$1 = b;
	              var _i = 0;
	              var same_length = len_a;
	              while(true) {
	                var i = _i;
	                if (i === same_length) {
	                  return 0;
	                } else {
	                  var res = caml_compare(a$1[i], b$1[i]);
	                  if (res !== 0) {
	                    return res;
	                  } else {
	                    _i = i + 1 | 0;
	                    continue ;
	                    
	                  }
	                }
	              }
	            } else if (len_a < len_b) {
	              var a$2 = a;
	              var b$2 = b;
	              var _i$1 = 0;
	              var short_length = len_a;
	              while(true) {
	                var i$1 = _i$1;
	                if (i$1 === short_length) {
	                  return -1;
	                } else {
	                  var res$1 = caml_compare(a$2[i$1], b$2[i$1]);
	                  if (res$1 !== 0) {
	                    return res$1;
	                  } else {
	                    _i$1 = i$1 + 1 | 0;
	                    continue ;
	                    
	                  }
	                }
	              }
	            } else {
	              var a$3 = a;
	              var b$3 = b;
	              var _i$2 = 0;
	              var short_length$1 = len_b;
	              while(true) {
	                var i$2 = _i$2;
	                if (i$2 === short_length$1) {
	                  return 1;
	                } else {
	                  var res$2 = caml_compare(a$3[i$2], b$3[i$2]);
	                  if (res$2 !== 0) {
	                    return res$2;
	                  } else {
	                    _i$2 = i$2 + 1 | 0;
	                    continue ;
	                    
	                  }
	                }
	              }
	            }
	          }
	        }
	      }
	    }
	  }
	}

	function caml_equal(_a, _b) {
	  while(true) {
	    var b = _b;
	    var a = _a;
	    if (a === b) {
	      return /* true */1;
	    } else {
	      var a_type = typeof a;
	      if (a_type === "string" || a_type === "number" || a_type === "boolean" || a_type === "undefined" || a === null) {
	        return /* false */0;
	      } else {
	        var b_type = typeof b;
	        if (a_type === "function" || b_type === "function") {
	          throw [
	                invalid_argument,
	                "equal: functional value"
	              ];
	        } else if (b_type === "number" || b_type === "undefined" || b === null) {
	          return /* false */0;
	        } else {
	          var tag_a = a.tag | 0;
	          var tag_b = b.tag | 0;
	          if (tag_a === 250) {
	            _a = a[0];
	            continue ;
	            
	          } else if (tag_b === 250) {
	            _b = b[0];
	            continue ;
	            
	          } else if (tag_a === 248) {
	            return +(a[1] === b[1]);
	          } else if (tag_a === 251) {
	            throw [
	                  invalid_argument,
	                  "equal: abstract value"
	                ];
	          } else if (tag_a !== tag_b) {
	            return /* false */0;
	          } else {
	            var len_a = a.length | 0;
	            var len_b = b.length | 0;
	            if (len_a === len_b) {
	              var a$1 = a;
	              var b$1 = b;
	              var _i = 0;
	              var same_length = len_a;
	              while(true) {
	                var i = _i;
	                if (i === same_length) {
	                  return /* true */1;
	                } else if (caml_equal(a$1[i], b$1[i])) {
	                  _i = i + 1 | 0;
	                  continue ;
	                  
	                } else {
	                  return /* false */0;
	                }
	              }
	            } else {
	              return /* false */0;
	            }
	          }
	        }
	      }
	    }
	  }
	}

	function caml_notequal(a, b) {
	  return 1 - caml_equal(a, b);
	}

	function caml_greaterequal(a, b) {
	  return +(caml_compare(a, b) >= 0);
	}

	function caml_greaterthan(a, b) {
	  return +(caml_compare(a, b) > 0);
	}

	function caml_lessequal(a, b) {
	  return +(caml_compare(a, b) <= 0);
	}

	function caml_lessthan(a, b) {
	  return +(caml_compare(a, b) < 0);
	}


	/* No side effect */

	/* stdin Not a pure module */

	/* No side effect */

	var imul = ( Math.imul || function (x,y) {
	  y |= 0; return ((((x >> 16) * y) << 16) + (x & 0xffff) * y)|0; 
	}
	);


	/* imul Not a pure module */

	/* repeat Not a pure module */

	/* two_ptr_32_dbl Not a pure module */

	/* float_of_string Not a pure module */

	function bytes_of_string(s) {
	  var len = s.length;
	  var res = new Array(len);
	  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
	    res[i] = s.charCodeAt(i);
	  }
	  return res;
	}


	/* No side effect */

	/* not_implemented Not a pure module */

	/* No side effect */

	function failwith(s) {
	  throw [
	        failure,
	        s
	      ];
	}

	var Exit = create$1("Pervasives.Exit");

	var min_int = -2147483648;

	function $at(l1, l2) {
	  if (l1) {
	    return /* :: */[
	            l1[0],
	            $at(l1[1], l2)
	          ];
	  } else {
	    return l2;
	  }
	}

	var max_int = 2147483647;


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var Check_fail = create$1("Exception-Wonderjs.Check_fail");


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function test(message, func) {
	  try {
	    return _1(func, /* () */0);
	  }
	  catch (raw_exn){
	    var exn = internalToOCamlException(raw_exn);
	    if (exn[0] === Check_fail) {
	      return failwith("" + (String(message) + ("->" + (String(exn[1]) + ""))));
	    } else {
	      throw exn;
	    }
	  }
	}

	function testWithMessageFunc(messageFunc, func) {
	  try {
	    return _1(func, /* () */0);
	  }
	  catch (raw_exn){
	    var exn = internalToOCamlException(raw_exn);
	    if (exn[0] === Check_fail) {
	      var message = _1(messageFunc, /* () */0);
	      return failwith("" + (String(message) + ("->" + (String(exn[1]) + ""))));
	    } else {
	      throw exn;
	    }
	  }
	}

	function requireCheck(f) {
	  var match = stateData[/* isTest */1];
	  if (match !== 0) {
	    return _1(f, /* () */0);
	  } else {
	    return /* () */0;
	  }
	}

	function ensureCheck(f, returnVal) {
	  var match = stateData[/* isTest */1];
	  if (match !== 0) {
	    _1(f, returnVal);
	    return returnVal;
	  } else {
	    return returnVal;
	  }
	}

	function _assert(result, message) {
	  if (result !== 0) {
	    return /* () */0;
	  } else {
	    throw [
	          Check_fail,
	          message
	        ];
	  }
	}

	function assertFail() {
	  throw [
	        Check_fail,
	        "fail"
	      ];
	}

	function assertPass() {
	  return /* () */0;
	}

	function assertTrue(source) {
	  return _assert(+(source === /* true */1), "expect to be true, but actual is false");
	}

	function assertFalse(source) {
	  return _assert(+(source === /* false */0), "expect to be false, but actual is true");
	}

	function assertJsTrue(source) {
	  return _assert(caml_equal(source, true), "expect to be true, but actual is false");
	}

	function assertIsBool(source) {
	  return _assert(+(source === /* true */1 || source === /* false */0), "expect to be bool, but actual not");
	}

	function assertExist(source) {
	  return _assert(isSome(source), "expect to be exist, but actual not");
	}

	function assertNotExist(source) {
	  return _assert(isNone(source), "expect to be not exist, but actual exist");
	}

	function _getEqualMessage(source, target) {
	  return "\"expect to be " + (String(source) + (", but actual is " + (String(target) + "\"")));
	}

	function assertEqual(_, source, target) {
	  return _assert(caml_equal(source, target), _getEqualMessage(source, target));
	}

	function assertNotEqual(_, source, target) {
	  return _assert(caml_notequal(source, target), _getEqualMessage(source, target));
	}

	function assertGt(_, source, target) {
	  return _assert(caml_greaterthan(source, target), "expect " + (String(source) + (" > " + (String(target) + ", but actual isn\'t"))));
	}

	function assertGte(_, source, target) {
	  return _assert(caml_greaterequal(source, target), "expect " + (String(source) + (" >= " + (String(target) + ", but actual isn\'t"))));
	}

	function assertLt(_, source, target) {
	  return _assert(caml_lessthan(source, target), "expect " + (String(source) + (" < " + (String(target) + ", but actual isn\'t"))));
	}

	function assertLte(_, source, target) {
	  return _assert(caml_lessequal(source, target), "expect " + (String(source) + (" <= " + (String(target) + ", but actual isn\'t"))));
	}

	function $eq(a, b) {
	  return assertEqual(/* Int */0, a, b);
	}

	function $eq$eq$dot(a, b) {
	  return assertEqual(/* Float */1, a, b);
	}

	function $eq$eq$caret(a, b) {
	  return assertEqual(/* String */2, a, b);
	}

	function $less$great$eq(a, b) {
	  return assertNotEqual(/* Int */0, a, b);
	}

	function $less$great$eq$dot(a, b) {
	  return assertNotEqual(/* Float */1, a, b);
	}

	function $great(a, b) {
	  return assertGt(/* Int */0, a, b);
	}

	function $great$dot(a, b) {
	  return assertGt(/* Float */1, a, b);
	}

	function $great$eq(a, b) {
	  return assertGte(/* Int */0, a, b);
	}

	function $great$eq$dot(a, b) {
	  return assertGte(/* Float */1, a, b);
	}

	function $less(a, b) {
	  return assertLt(/* Int */0, a, b);
	}

	function $less$dot(a, b) {
	  return assertLt(/* Float */1, a, b);
	}

	function $less$eq(a, b) {
	  return assertLte(/* Int */0, a, b);
	}

	function $less$eq$dot(a, b) {
	  return assertLte(/* Float */1, a, b);
	}

	var Operators = /* module */[
	  /* = */$eq,
	  /* ==. */$eq$eq$dot,
	  /* ==^ */$eq$eq$caret,
	  /* <>= */$less$great$eq,
	  /* <>=. */$less$great$eq$dot,
	  /* > */$great,
	  /* >. */$great$dot,
	  /* >= */$great$eq,
	  /* >=. */$great$eq$dot,
	  /* < */$less,
	  /* <. */$less$dot,
	  /* <= */$less$eq,
	  /* <=. */$less$eq$dot
	];


	/* No side effect */

	function entries(dict) {
	  var keys = Object.keys(dict);
	  var l = keys.length;
	  var values = new Array(l);
	  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
	    var key = keys[i];
	    values[i] = /* tuple */[
	      key,
	      dict[key]
	    ];
	  }
	  return values;
	}

	function fromList$1(entries) {
	  var dict = { };
	  var _param = entries;
	  while(true) {
	    var param = _param;
	    if (param) {
	      var match = param[0];
	      dict[match[0]] = match[1];
	      _param = param[1];
	      continue ;
	      
	    } else {
	      return dict;
	    }
	  }
	}


	/* unsafeDeleteKey Not a pure module */

	function undefined_to_opt(x) {
	  if (x === undefined) {
	    return /* None */0;
	  } else {
	    return /* Some */[x];
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function createEmpty$1() {
	  return { };
	}

	function set(key, value, map$$1) {
	  map$$1[key] = value;
	  return map$$1;
	}

	function get$2(key, map$$1) {
	  return undefined_to_opt(map$$1[key]);
	}

	function unsafeGet(key, map$$1) {
	  return map$$1[key];
	}

	function has(key, map$$1) {
	  return isSome(undefined_to_opt(map$$1[key]));
	}

	var fromList = fromList$1;


	/* Js_dict Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function createEmpty() {
	  return /* array */[];
	}

	function removeDuplicateItems(arr) {
	  var resultArr = /* array */[];
	  var map = createEmpty$1(/* () */0);
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    var item = arr[i];
	    var key = item.toString();
	    var match = get$2(key, map);
	    if (!match) {
	      resultArr.push(item);
	      set(key, item, map);
	    }
	    
	  }
	  return resultArr;
	}

	function get$1(index, arr) {
	  if (index >= arr.length) {
	    return /* None */0;
	  } else {
	    return /* Some */[arr[index]];
	  }
	}

	function isNotEqual(index, target, arr) {
	  if (index >= arr.length) {
	    return /* true */1;
	  } else {
	    return caml_notequal(arr[index], target);
	  }
	}

	function forEach(func, arr) {
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    func(arr[i]);
	  }
	  return /* () */0;
	}

	function forEachi(func, arr) {
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    func(arr[i], i);
	  }
	  return /* () */0;
	}


	/* HashMapSystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function deleteBySwap(index, lastIndex, arr) {
	  requireCheck((function () {
	          return test("lastIndex should == arr.length", (function () {
	                        return assertEqual(/* Int */0, arr.length - 1 | 0, lastIndex);
	                      }));
	        }));
	  arr[index] = arr[lastIndex];
	  arr.pop();
	  return /* () */0;
	}

	function range(a, b) {
	  var result = createEmpty(/* () */0);
	  for(var i = a; i <= b; ++i){
	    result.push(i);
	  }
	  return result;
	}

	function reduceState(func, state, arr) {
	  var mutableState = state;
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    mutableState = func(mutableState, arr[i]);
	  }
	  return mutableState;
	}

	function reduceOneParam(func, param, arr) {
	  var mutableParam = param;
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    mutableParam = func(mutableParam, arr[i]);
	  }
	  return mutableParam;
	}

	function reduceOneParami(func, param, arr) {
	  var mutableParam = param;
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    mutableParam = func(mutableParam, arr[i], i);
	  }
	  return mutableParam;
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getMaxDisposeCount(state) {
	  return state[/* memoryConfig */2][/* maxDisposeCount */0];
	}

	function getMaxTypeArrayPoolSize(state) {
	  return state[/* memoryConfig */2][/* maxTypeArrayPoolSize */1];
	}

	function getMaxBigTypeArrayPoolSize(state) {
	  return state[/* memoryConfig */2][/* maxBigTypeArrayPoolSize */2];
	}

	function initData() {
	  return /* record */[
	          /* maxDisposeCount */1000,
	          /* maxTypeArrayPoolSize */5000,
	          /* maxBigTypeArrayPoolSize */100
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function createEmpty$2() {
	  return /* array */[];
	}

	function unsafeGet$1(key, map) {
	  return map[key];
	}

	function get$3(key, map) {
	  var value = map[key];
	  var match = +(value === undefined);
	  if (match !== 0) {
	    return /* None */0;
	  } else {
	    return /* Some */[value];
	  }
	}

	function has$1(key, map) {
	  return caml_notequal(map[key], undefined);
	}

	function set$1(key, value, map) {
	  map[key] = value;
	  return map;
	}

	function deleteVal$1(key, map) {
	  map[key] = undefined;
	  return map;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var isDisposed = has$1;

	function isDisposeTooMany(disposeCount, state) {
	  return +(disposeCount >= getMaxDisposeCount(state));
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function log(message) {
	  console.log(message);
	  return /* () */0;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getIntersectShaderRelatedMap(intersectShaderIndexDataArray, currentMap) {
	  return reduceOneParam((function (intersectMap, param) {
	                set$1(param[1], unsafeGet$1(param[0], currentMap), intersectMap);
	                return intersectMap;
	              }), createEmpty$2(/* () */0), intersectShaderIndexDataArray);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function createProgram(gl) {
	  return gl.createProgram();
	}

	function _compileShader(gl, glslSource, shader) {
	  gl.shaderSource(shader, glslSource);
	  gl.compileShader(shader);
	  return ensureCheck((function (shader) {
	                return test("judge shader parameter", (function () {
	                              if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
	                                log(gl.getShaderInfoLog(shader));
	                                return log("source:\n            " + (String(glslSource) + ""));
	                              } else {
	                                return 0;
	                              }
	                            }));
	              }), shader);
	}

	function _linkProgram(program, gl) {
	  return ensureCheck((function () {
	                return testWithMessageFunc((function () {
	                              var message = gl.getProgramInfoLog(program);
	                              return "link program error:" + (String(message) + "");
	                            }), (function () {
	                              return assertJsTrue(gl.getProgramParameter(program, gl.LINK_STATUS));
	                            }));
	              }), (gl.linkProgram(program), 0));
	}

	function initShader(vsSource, fsSource, gl, program) {
	  var vs = _compileShader(gl, vsSource, gl.createShader(gl.VERTEX_SHADER));
	  var fs = _compileShader(gl, fsSource, gl.createShader(gl.FRAGMENT_SHADER));
	  gl.attachShader(program, vs);
	  gl.attachShader(program, fs);
	  gl.bindAttribLocation(program, 0, "a_position");
	  _linkProgram(program, gl);
	  gl.deleteShader(vs);
	  gl.deleteShader(fs);
	  return program;
	}

	function unsafeGetProgram(shaderIndex, state) {
	  return ensureCheck((function () {
	                return test("program should exist", (function () {
	                              return assertExist(get$3(shaderIndex, state[/* programData */17][/* programMap */0]));
	                            }));
	              }), unsafeGet$1(shaderIndex, state[/* programData */17][/* programMap */0]));
	}

	function registerProgram(shaderIndex, state, program) {
	  set$1(shaderIndex, program, state[/* programData */17][/* programMap */0]);
	  return program;
	}

	function use(gl, program, state) {
	  var data = state[/* programData */17];
	  var match = data[/* lastUsedProgram */1];
	  var exit = 0;
	  if (match) {
	    if (program === match[0]) {
	      return state;
	    } else {
	      exit = 1;
	    }
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    data[/* lastUsedProgram */1] = /* Some */[program];
	    gl.useProgram(program);
	    return state;
	  }
	  
	}

	function deepCopyStateForRestore$4(state) {
	  return state;
	}

	function restore$2(intersectShaderIndexDataArray, currentState, targetState) {
	  var match = currentState[/* programData */17];
	  var newrecord = targetState.slice();
	  newrecord[/* programData */17] = /* record */[
	    /* programMap */getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* programMap */0]),
	    /* lastUsedProgram : None */0
	  ];
	  return newrecord;
	}


	/* ShaderRestoreFromStateUtils-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var entries$1 = entries;


	/* Js_dict Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getShaderData(state) {
	  return state[/* shaderData */16];
	}

	function getGLSLData(state) {
	  return state[/* shaderData */16][/* glslData */2];
	}

	function deepCopyStateForRestore$5(state) {
	  var match = state[/* shaderData */16];
	  var index = match[/* index */0];
	  var shaderIndexMap = match[/* shaderIndexMap */1];
	  var match$1 = state[/* shaderData */16][/* glslData */2];
	  var precision = match$1[/* precision */0];
	  var newrecord = state.slice();
	  newrecord[/* shaderData */16] = /* record */[
	    /* index */index,
	    /* shaderIndexMap */shaderIndexMap,
	    /* glslData : record */[/* precision */precision]
	  ];
	  return newrecord;
	}

	function getIntersectShaderIndexDataArray$1(currentState, targetState) {
	  var match = currentState[/* shaderData */16];
	  var currentShaderIndexMap = match[/* shaderIndexMap */1];
	  var match$1 = targetState[/* shaderData */16];
	  var targetShaderIndexMap = match$1[/* shaderIndexMap */1];
	  return reduceOneParam((function (dataArr, param) {
	                dataArr.push(/* tuple */[
	                      unsafeGet(param[0], currentShaderIndexMap),
	                      param[1]
	                    ]);
	                return dataArr;
	              }), /* array */[], entries$1(targetShaderIndexMap).filter((function (param) {
	                    return has(param[0], currentShaderIndexMap);
	                  })));
	}

	function _getIntersectShaderIndexMap(currentShaderIndexMap, targetShaderIndexMap) {
	  var intersectShaderIndexDataArr = entries$1(targetShaderIndexMap).filter((function (param) {
	          return has(param[0], currentShaderIndexMap);
	        }));
	  return /* tuple */[
	          intersectShaderIndexDataArr.length,
	          reduceOneParam((function (shaderMap, param) {
	                  return set(param[0], param[1], shaderMap);
	                }), createEmpty$1(/* () */0), intersectShaderIndexDataArr)
	        ];
	}

	function restore$3(currentState, targetState) {
	  requireCheck((function () {
	          return test("currentState and targetState ->shaderData->glslData->precision should be the same", (function () {
	                        var match = currentState[/* shaderData */16][/* glslData */2][/* precision */0];
	                        var match$1 = targetState[/* shaderData */16][/* glslData */2][/* precision */0];
	                        if (match) {
	                          if (match$1) {
	                            return Operators[/* ==^ */2](match[0], match$1[0]);
	                          } else {
	                            return assertFail(/* () */0);
	                          }
	                        } else if (match$1) {
	                          return assertFail(/* () */0);
	                        } else {
	                          return assertPass(/* () */0);
	                        }
	                      }));
	        }));
	  var match = currentState[/* shaderData */16];
	  var currentShaderIndexMap = match[/* shaderIndexMap */1];
	  var targetShaderData = targetState[/* shaderData */16];
	  var targetShaderIndexMap = targetShaderData[/* shaderIndexMap */1];
	  var match$1 = _getIntersectShaderIndexMap(currentShaderIndexMap, targetShaderIndexMap);
	  var newrecord = targetState.slice();
	  newrecord[/* shaderData */16] = /* record */[
	    /* index */match$1[0],
	    /* shaderIndexMap */match$1[1],
	    /* glslData */targetShaderData[/* glslData */2]
	  ];
	  return newrecord;
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getChunk(name, state) {
	  return getExn(get$2(name, state[/* glslChunkData */20][/* chunkMap */0]));
	}

	function initData$2() {
	  return /* record */[/* chunkMap */set("webgl1_basic_end_fragment", /* record */[
	                /* top */"\n\n",
	                /* define */"\n\n",
	                /* varDeclare */"\n\n",
	                /* funcDeclare */"\n\n",
	                /* funcDefine */"\n\n",
	                /* body */"\ngl_FragColor = vec4(totalColor.rgb, totalColor.a);\n"
	              ], set("webgl1_basic_fragment", /* record */[
	                    /* top */"\n\n",
	                    /* define */"\n\n",
	                    /* varDeclare */"\n\n",
	                    /* funcDeclare */"\n\n",
	                    /* funcDefine */"\n\n",
	                    /* body */"\nvec4 totalColor = vec4(u_color, 1.0);\n"
	                  ], set("webgl1_basic_vertex", /* record */[
	                        /* top */"\n\n",
	                        /* define */"\n\n",
	                        /* varDeclare */"\n\n",
	                        /* funcDeclare */"\n\n",
	                        /* funcDefine */"\n\n",
	                        /* body */"\ngl_Position = u_pMatrix * u_vMatrix * mMatrix * vec4(a_position, 1.0);\n"
	                      ], set("common_define", /* record */[
	                            /* top */"\n\n",
	                            /* define */"\n\n",
	                            /* varDeclare */"\n\n",
	                            /* funcDeclare */"\n\n",
	                            /* funcDefine */"\n\n",
	                            /* body */"\n\n"
	                          ], set("common_fragment", /* record */[
	                                /* top */"\n\n",
	                                /* define */"\n\n",
	                                /* varDeclare */"\n\n",
	                                /* funcDeclare */"\n\n",
	                                /* funcDefine */"\n\n",
	                                /* body */"\n\n"
	                              ], set("common_function", /* record */[
	                                    /* top */"\n\n",
	                                    /* define */"\n\n",
	                                    /* varDeclare */"\n\n",
	                                    /* funcDeclare */"\n\n",
	                                    /* funcDefine */"\n// mat2 transpose(mat2 m) {\n//   return mat2(  m[0][0], m[1][0],   // new col 0\n//                 m[0][1], m[1][1]    // new col 1\n//              );\n//   }\n\n// mat3 transpose(mat3 m) {\n//   return mat3(  m[0][0], m[1][0], m[2][0],  // new col 0\n//                 m[0][1], m[1][1], m[2][1],  // new col 1\n//                 m[0][2], m[1][2], m[2][2]   // new col 1\n//              );\n//   }\n\n//bool isRenderArrayEmpty(int isRenderArrayEmpty){\n//  return isRenderArrayEmpty == 1;\n//}\n",
	                                    /* body */"\n\n"
	                                  ], set("common_vertex", /* record */[
	                                        /* top */"\n\n",
	                                        /* define */"\n\n\n// #export \n\n// ##name\n// aaaa\n// ##end\n\n// ##body\n\n\n// ##end\n\n\n// #end\n",
	                                        /* varDeclare */"\n\n",
	                                        /* funcDeclare */"\n\n",
	                                        /* funcDefine */"\n// #import * from \"common_function\"\n// mat2 transpose(mat2 m) {\n//   return mat2(  m[0][0], m[1][0],   // new col 0\n//                 m[0][1], m[1][1]    // new col 1\n//              );\n//   }\n\n// mat3 transpose(mat3 m) {\n//   return mat3(  m[0][0], m[1][0], m[2][0],  // new col 0\n//                 m[0][1], m[1][1], m[2][1],  // new col 1\n//                 m[0][2], m[1][2], m[2][2]   // new col 1\n//              );\n//   }\n\n//bool isRenderArrayEmpty(int isRenderArrayEmpty){\n//  return isRenderArrayEmpty == 1;\n//}\n",
	                                        /* body */"\n\n"
	                                      ], set("highp_fragment", /* record */[
	                                            /* top */"\nprecision highp float;\nprecision highp int;\n",
	                                            /* define */"\n\n",
	                                            /* varDeclare */"\n\n",
	                                            /* funcDeclare */"\n\n",
	                                            /* funcDefine */"\n\n",
	                                            /* body */"\n\n"
	                                          ], set("lowp_fragment", /* record */[
	                                                /* top */"\nprecision lowp float;\nprecision lowp int;\n",
	                                                /* define */"\n\n",
	                                                /* varDeclare */"\n\n",
	                                                /* funcDeclare */"\n\n",
	                                                /* funcDefine */"\n\n",
	                                                /* body */"\n\n"
	                                              ], set("mediump_fragment", /* record */[
	                                                    /* top */"\nprecision mediump float;\nprecision mediump int;\n",
	                                                    /* define */"\n\n",
	                                                    /* varDeclare */"\n\n",
	                                                    /* funcDeclare */"\n\n",
	                                                    /* funcDefine */"\n\n",
	                                                    /* body */"\n\n"
	                                                  ], set("webgl1_setPos_mvp", /* record */[
	                                                        /* top */"\n\n",
	                                                        /* define */"\n\n",
	                                                        /* varDeclare */"\n\n",
	                                                        /* funcDeclare */"\n\n",
	                                                        /* funcDefine */"\n\n",
	                                                        /* body */"\ngl_Position = u_pMatrix * u_vMatrix * mMatrix * vec4(a_position, 1.0);\n"
	                                                      ], set("modelMatrix_batch_instance_vertex", /* record */[
	                                                            /* top */"\n\n",
	                                                            /* define */"\n\n",
	                                                            /* varDeclare */"\n\n",
	                                                            /* funcDeclare */"\n\n",
	                                                            /* funcDefine */"\n\n",
	                                                            /* body */"\nmat4 mMatrix = u_mMatrix;\n"
	                                                          ], set("modelMatrix_hardware_instance_vertex", /* record */[
	                                                                /* top */"\n\n",
	                                                                /* define */"\n\n",
	                                                                /* varDeclare */"\n\n",
	                                                                /* funcDeclare */"\n\n",
	                                                                /* funcDefine */"\n\n",
	                                                                /* body */"\nmat4 mMatrix = mat4(a_mVec4_0, a_mVec4_1, a_mVec4_2, a_mVec4_3);\n"
	                                                              ], set("modelMatrix_noInstance_vertex", /* record */[
	                                                                    /* top */"\n\n",
	                                                                    /* define */"\n\n",
	                                                                    /* varDeclare */"\n\n",
	                                                                    /* funcDeclare */"\n\n",
	                                                                    /* funcDefine */"\n\n",
	                                                                    /* body */"\nmat4 mMatrix = u_mMatrix;\n"
	                                                                  ], createEmpty$1(/* () */0)))))))))))))))];
	}


	/* HashMapSystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var throwMessage = failwith;


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var webgl1_main_begin = "void main(void){\n";

	var webgl1_main_end = "}\n";

	function _generateAttributeSource(shaderLibDataArr) {
	  return shaderLibDataArr.reduce((function (result, param) {
	                var variables = param[/* variables */2];
	                if (variables) {
	                  var match = variables[0][/* attributes */1];
	                  if (match) {
	                    return result + match[0].reduce((function (result, param) {
	                                  var type_ = param[/* type_ */2];
	                                  var name = param[/* name */0];
	                                  if (name && type_) {
	                                    return result + ("attribute " + (String(type_[0]) + (" " + (String(name[0]) + ";\n  "))));
	                                  } else {
	                                    return result;
	                                  }
	                                }), "");
	                  } else {
	                    return result;
	                  }
	                } else {
	                  return result;
	                }
	              }), "");
	}

	function _isInSource(key, source) {
	  return +(source.indexOf(key) > -1);
	}

	function _generateUniformSource(shaderLibDataArr, sourceVarDeclare, sourceFuncDefine, sourceBody) {
	  return shaderLibDataArr.reduce((function (result, param) {
	                var variables = param[/* variables */2];
	                if (variables) {
	                  var match = variables[0][/* uniforms */0];
	                  if (match) {
	                    return result + match[0].filter((function (param) {
	                                    var name = param[/* name */0];
	                                    if (_isInSource(name, sourceVarDeclare) || _isInSource(name, sourceFuncDefine)) {
	                                      return /* true */1;
	                                    } else {
	                                      return _isInSource(name, sourceBody);
	                                    }
	                                  })).reduce((function (result, param) {
	                                  return result + ("uniform " + (String(param[/* type_ */2]) + (" " + (String(param[/* name */0]) + ";\n"))));
	                                }), "");
	                  } else {
	                    return result;
	                  }
	                } else {
	                  return result;
	                }
	              }), "");
	}

	function getPrecisionSource$1(state) {
	  var match = getGpuDetectData(state);
	  var match$1 = getExn(match[/* precision */1]);
	  switch (match$1) {
	    case 0 : 
	        return getChunk("highp_fragment", state)[/* top */0];
	    case 1 : 
	        return getChunk("mediump_fragment", state)[/* top */0];
	    case 2 : 
	        return getChunk("lowp_fragment", state)[/* top */0];
	    
	  }
	}

	function buildGLSLSource(_, shaderLibDataArr, state) {
	  var match = getGLSLData(state);
	  var precision = match[/* precision */0];
	  var vs = /* record */[
	    /* top */"",
	    /* define */"",
	    /* varDeclare */"",
	    /* funcDeclare */"",
	    /* funcDefine */"",
	    /* body */""
	  ];
	  var fs = /* record */[
	    /* top */"",
	    /* define */"",
	    /* varDeclare */"",
	    /* funcDeclare */"",
	    /* funcDefine */"",
	    /* body */""
	  ];
	  var _setSource = function (sourceChunk, param) {
	    var sourceTop = sourceChunk[/* top */0];
	    var sourceDefine = sourceChunk[/* define */1];
	    var sourceVarDeclare = sourceChunk[/* varDeclare */2];
	    var sourceFuncDeclare = sourceChunk[/* funcDeclare */3];
	    var sourceFuncDefine = sourceChunk[/* funcDefine */4];
	    var sourceBody = sourceChunk[/* body */5];
	    var top = param[/* top */0];
	    var define = param[/* define */1];
	    var varDeclare = param[/* varDeclare */2];
	    var funcDeclare = param[/* funcDeclare */3];
	    var funcDefine = param[/* funcDefine */4];
	    var body = param[/* body */5];
	    sourceChunk[/* top */0] = sourceTop + top;
	    sourceChunk[/* define */1] = sourceDefine + define;
	    sourceChunk[/* varDeclare */2] = sourceVarDeclare + varDeclare;
	    sourceChunk[/* funcDeclare */3] = sourceFuncDeclare + funcDeclare;
	    sourceChunk[/* funcDefine */4] = sourceFuncDefine + funcDefine;
	    sourceChunk[/* body */5] = sourceBody + body;
	    return /* () */0;
	  };
	  vs[/* body */5] = vs[/* body */5] + webgl1_main_begin;
	  fs[/* body */5] = fs[/* body */5] + webgl1_main_begin;
	  fs[/* top */0] = getExn(precision) + fs[/* top */0];
	  shaderLibDataArr.forEach((function (param) {
	          var glsls = param[/* glsls */1];
	          if (glsls) {
	            glsls[0].forEach((function (param) {
	                    var name = param[/* name */1];
	                    var type_ = param[/* type_ */0];
	                    switch (type_) {
	                      case "fs" : 
	                          return _setSource(fs, getChunk(name, state));
	                      case "vs" : 
	                          return _setSource(vs, getChunk(name, state));
	                      default:
	                        return throwMessage("unknow glsl type:" + (String(type_) + ""));
	                    }
	                  }));
	            return /* () */0;
	          } else {
	            return /* () */0;
	          }
	        }));
	  vs[/* body */5] = vs[/* body */5] + webgl1_main_end;
	  fs[/* body */5] = fs[/* body */5] + webgl1_main_end;
	  vs[/* top */0] = vs[/* top */0] + _generateAttributeSource(shaderLibDataArr);
	  vs[/* top */0] = vs[/* top */0] + _generateUniformSource(shaderLibDataArr, vs[/* varDeclare */2], vs[/* funcDefine */4], vs[/* body */5]);
	  fs[/* top */0] = fs[/* top */0] + _generateUniformSource(shaderLibDataArr, fs[/* varDeclare */2], fs[/* funcDefine */4], fs[/* body */5]);
	  return /* tuple */[
	          vs[/* top */0] + (vs[/* define */1] + (vs[/* varDeclare */2] + (vs[/* funcDeclare */3] + (vs[/* funcDefine */4] + vs[/* body */5])))),
	          fs[/* top */0] + (fs[/* define */1] + (fs[/* varDeclare */2] + (fs[/* funcDeclare */3] + (fs[/* funcDefine */4] + fs[/* body */5]))))
	        ];
	}


	/* ShaderChunkSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isSame(a, b) {
	  return +(a === b);
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getParent$1(index, transformData) {
	  return undefined_to_opt(unsafeGet$1(index, transformData[/* parentMap */1]));
	}

	function removeFromParentMap(childIndex, transformData) {
	  deleteVal$1(childIndex, transformData[/* parentMap */1]);
	  return transformData;
	}

	function unsafeGetChildren$1(index, transformData) {
	  return ensureCheck((function () {
	                return test("children should exist", (function () {
	                              return assertExist(get$3(index, transformData[/* childMap */2]));
	                            }));
	              }), unsafeGet$1(index, transformData[/* childMap */2]));
	}

	function _removeChild(childIndex, children) {
	  return deleteBySwap(children.indexOf(childIndex), children.length - 1 | 0, children);
	}

	function removeFromChildMap(parentIndex, childIndex, transformData) {
	  _removeChild(childIndex, unsafeGetChildren$1(parentIndex, transformData));
	  return transformData;
	}

	function _removeFromParent(currentParentIndex, child, transformData) {
	  return removeFromChildMap(currentParentIndex, child, removeFromParentMap(child, transformData));
	}

	function _setParent(parent, childIndex, transformData) {
	  set$1(childIndex, parent, transformData[/* parentMap */1]);
	  return transformData;
	}

	function _addChild(parentIndex, child, transformData) {
	  unsafeGetChildren$1(parentIndex, transformData).push(child);
	  return transformData;
	}

	function _addToParent(parent, child, transformData) {
	  requireCheck((function () {
	          test("child shouldn't has parent", (function () {
	                  return assertNotExist(getParent$1(child, transformData));
	                }));
	          return test("parent shouldn't already has the child", (function () {
	                        return assertFalse(+unsafeGetChildren$1(parent, transformData).includes(child));
	                      }));
	        }));
	  return _addChild(parent, child, _setParent(parent, child, transformData));
	}

	function setParent$1(parent, child, transformData) {
	  if (parent) {
	    var newParent = parent[0];
	    var match = getParent$1(child, transformData);
	    if (match) {
	      var currentParent = match[0];
	      var match$1 = 1 - isSame(currentParent, newParent);
	      if (match$1 !== 0) {
	        return _addToParent(newParent, child, _removeFromParent(currentParent, child, transformData));
	      } else {
	        return transformData;
	      }
	    } else {
	      return _addToParent(newParent, child, transformData);
	    }
	  } else {
	    var match$2 = getParent$1(child, transformData);
	    if (match$2) {
	      return _removeFromParent(match$2[0], child, transformData);
	    } else {
	      return transformData;
	    }
	  }
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function mark(transform, isDirty, data) {
	  set$1(transform, isDirty, data[/* dirtyMap */6]);
	  return data;
	}

	function markHierachyDirty(transform, data) {
	  return reduceOneParam((function (data, child) {
	                return markHierachyDirty(child, data);
	              }), data, unsafeGetChildren$1(transform, mark(transform, /* true */1, data)));
	}

	function isDirty(transform, data) {
	  var dirtyMap = data[/* dirtyMap */6];
	  return ensureCheck((function (isDirty) {
	                return test("should return bool", (function () {
	                              assertExist(get$3(transform, dirtyMap));
	                              return assertIsBool(isDirty);
	                            }));
	              }), unsafeGet$1(transform, dirtyMap));
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function copyFloat32Array(typeArr) {
	  if (typeArr === undefined) {
	    return undefined;
	  } else {
	    return typeArr.slice();
	  }
	}

	function deepCopyFloat32ArrayArray(arr) {
	  return reduceOneParam((function (newArr, typeArr) {
	                newArr.push(copyFloat32Array(typeArr));
	                return newArr;
	              }), /* array */[], arr);
	}

	function deepCopyArrayArray(arr) {
	  return reduceOneParam((function (newArr, arr) {
	                newArr.push(arr.slice());
	                return newArr;
	              }), /* array */[], arr);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function copy$1(prim) {
	  return prim.slice();
	}

	function getValidKeys(map) {
	  return reduceOneParami((function (arr, value, key) {
	                if (value === undefined) {
	                  return arr;
	                } else {
	                  arr.push(key);
	                  return arr;
	                }
	              }), /* int array */[], map);
	}

	function forEachValid(func, map) {
	  return forEach((function (value) {
	                if (value === undefined) {
	                  return /* () */0;
	                } else {
	                  return func(value);
	                }
	              }), map);
	}

	function reduceiValid(func, initValue, map) {
	  return reduceOneParami((function (previousValue, value, index) {
	                if (value === undefined) {
	                  return previousValue;
	                } else {
	                  return func(previousValue, value, index);
	                }
	              }), initValue, map);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getFloat32ArrayPoolMap(state) {
	  return state[/* typeArrayPoolData */26][/* float32ArrayPoolMap */0];
	}

	function getUint16ArrayPoolMap(state) {
	  return state[/* typeArrayPoolData */26][/* uint16ArrayPoolMap */1];
	}

	function _addTypeArrayToPool(count, typeArray, maxSize, map) {
	  var match = get$3(count, map);
	  if (match) {
	    var arr = match[0];
	    var len = arr.length;
	    if (len >= maxSize) {
	      return map;
	    } else {
	      arr.push(typeArray);
	      return map;
	    }
	  } else {
	    return set$1(count, /* array */[typeArray], map);
	  }
	}

	function addFloat32TypeArrayToPool(typeArray, maxSize, map) {
	  return _addTypeArrayToPool(typeArray.length, typeArray, maxSize, map);
	}

	function addUint16TypeArrayToPool(typeArray, maxSize, map) {
	  return _addTypeArrayToPool(typeArray.length, typeArray, maxSize, map);
	}

	function _getTypeArrayFromPool(count, map) {
	  var match = get$3(count, map);
	  if (match) {
	    var arr = match[0];
	    var match$1 = arr.length;
	    if (match$1 !== 0) {
	      return undefined_to_opt(arr.pop());
	    } else {
	      return /* None */0;
	    }
	  } else {
	    return /* None */0;
	  }
	}

	function getFloat32TypeArrayFromPool(count, state) {
	  return _getTypeArrayFromPool(count, state[/* typeArrayPoolData */26][/* float32ArrayPoolMap */0]);
	}

	function getUint16TypeArrayFromPool(count, state) {
	  return _getTypeArrayFromPool(count, state[/* typeArrayPoolData */26][/* uint16ArrayPoolMap */1]);
	}

	function addAllFloat32TypeArrayToPool(typeArrayMap, maxSize, map) {
	  forEachValid((function (typeArray) {
	          addFloat32TypeArrayToPool(typeArray, maxSize, map);
	          return /* () */0;
	        }), typeArrayMap);
	  return map;
	}

	function addAllUint16TypeArrayToPool(typeArrayMap, maxSize, map) {
	  forEachValid((function (typeArray) {
	          addUint16TypeArrayToPool(typeArray, maxSize, map);
	          return /* () */0;
	        }), typeArrayMap);
	  return map;
	}

	function deepCopyStateForRestore$9(state) {
	  var newrecord = state.slice();
	  newrecord[/* typeArrayPoolData */26] = /* record */[
	    /* float32ArrayPoolMap */createEmpty$2(/* () */0),
	    /* uint16ArrayPoolMap */createEmpty$2(/* () */0)
	  ];
	  return newrecord;
	}

	function restore$7(_, param, targetState) {
	  var newrecord = targetState.slice();
	  newrecord[/* typeArrayPoolData */26] = /* record */[
	    /* float32ArrayPoolMap */param[/* float32ArrayPoolMap */1],
	    /* uint16ArrayPoolMap */param[/* uint16ArrayPoolMap */2]
	  ];
	  return newrecord;
	}


	/* SparseMapSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function addTypeArrayToPool(transform, maxSize, localToWorldMatrixMap, localPositionMap, state) {
	  addFloat32TypeArrayToPool(unsafeGet$1(transform, localToWorldMatrixMap), maxSize, getFloat32ArrayPoolMap(state));
	  addFloat32TypeArrayToPool(unsafeGet$1(transform, localPositionMap), maxSize, getFloat32ArrayPoolMap(state));
	  return state;
	}

	function addAllTypeArrayToPool(maxSize, localToWorldMatrixMap, localPositionMap, float32ArrayPoolMap) {
	  return addAllFloat32TypeArrayToPool(localPositionMap, maxSize, addAllFloat32TypeArrayToPool(localToWorldMatrixMap, maxSize, float32ArrayPoolMap));
	}


	/* TypeArrayPoolSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getTransformData$2(state) {
	  return getExn(state[/* transformData */11]);
	}

	function deepCopyStateForRestore$8(state) {
	  var match = getExn(state[/* transformData */11]);
	  var index = match[/* index */0];
	  var disposedIndexArray = match[/* disposedIndexArray */7];
	  var newrecord = state.slice();
	  newrecord[/* transformData */11] = /* Some */[/* record */[
	      /* index */index,
	      /* parentMap */copy$1(match[/* parentMap */1]),
	      /* childMap */copy$1(match[/* childMap */2]),
	      /* gameObjectMap */copy$1(match[/* gameObjectMap */3]),
	      /* localToWorldMatrixMap */deepCopyFloat32ArrayArray(match[/* localToWorldMatrixMap */4]),
	      /* localPositionMap */deepCopyFloat32ArrayArray(match[/* localPositionMap */5]),
	      /* dirtyMap */copy$1(match[/* dirtyMap */6]),
	      /* disposedIndexArray */disposedIndexArray.slice()
	    ]];
	  return newrecord;
	}

	function restore$6(currentState, sharedData, targetState) {
	  var match = getExn(currentState[/* transformData */11]);
	  var float32ArrayPoolMap = addAllTypeArrayToPool(getMaxTypeArrayPoolSize(targetState), match[/* localToWorldMatrixMap */4], match[/* localPositionMap */5], sharedData[/* float32ArrayPoolMap */1]);
	  return /* tuple */[
	          targetState,
	          /* record */[
	            /* gl */sharedData[/* gl */0],
	            /* float32ArrayPoolMap */float32ArrayPoolMap,
	            /* uint16ArrayPoolMap */sharedData[/* uint16ArrayPoolMap */2]
	          ]
	        ];
	}


	/* CopyStateUtils-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function setFloat3(index, data, typeArray) {
	  requireCheck((function () {
	          return test("data.length should === 3", (function () {
	                        return Operators[/* = */0](data.length, 3);
	                      }));
	        }));
	  for(var i = index ,i_finish = index + 2 | 0; i <= i_finish; ++i){
	    typeArray[i] = data[i - index | 0];
	  }
	  return typeArray;
	}

	function setFloat16(index, data, typeArray) {
	  requireCheck((function () {
	          return test("data.length should === 16", (function () {
	                        return Operators[/* = */0](data.length, 16);
	                      }));
	        }));
	  for(var i = index ,i_finish = index + 15 | 0; i <= i_finish; ++i){
	    typeArray[i] = data[i - index | 0];
	  }
	  return typeArray;
	}

	function fillFloat32Array(typeArr, dataArr, startIndex) {
	  requireCheck((function () {
	          return test("should not exceed Float32Array range", (function () {
	                        return Operators[/* <= */11](dataArr.length + startIndex | 0, typeArr.length);
	                      }));
	        }));
	  var dataArrIndex = 0;
	  for(var i = startIndex ,i_finish = (startIndex + dataArr.length | 0) - 1 | 0; i <= i_finish; ++i){
	    typeArr[i] = dataArr[dataArrIndex];
	    dataArrIndex = dataArrIndex + 1 | 0;
	  }
	  return typeArr;
	}

	function fillFloat32ArrayWithFloat32Array(targetTypeArr, targetStartIndex, sourceTypeArr, sourceStartIndex, endIndex) {
	  var typeArrIndex = targetStartIndex;
	  for(var i = sourceStartIndex ,i_finish = endIndex - 1 | 0; i <= i_finish; ++i){
	    targetTypeArr[typeArrIndex] = sourceTypeArr[i];
	    typeArrIndex = typeArrIndex + 1 | 0;
	  }
	  return typeArrIndex;
	}

	function fillUint16Array(typeArr, dataArr, startIndex) {
	  requireCheck((function () {
	          return test("should not exceed Uint16Array range", (function () {
	                        return Operators[/* <= */11](dataArr.length + startIndex | 0, typeArr.length);
	                      }));
	        }));
	  var dataArrIndex = 0;
	  for(var i = startIndex ,i_finish = (startIndex + dataArr.length | 0) - 1 | 0; i <= i_finish; ++i){
	    typeArr[i] = dataArr[dataArrIndex];
	    dataArrIndex = dataArrIndex + 1 | 0;
	  }
	  return typeArr;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function addComponentToGameObjectMap(component, gameObjectUid, gameObjectMap) {
	  set$1(component, gameObjectUid, gameObjectMap);
	  return /* () */0;
	}

	var getComponentGameObject = get$3;

	function unsafeGetComponentGameObject(component, gameObjectMap) {
	  return ensureCheck((function () {
	                return test("component's gameObject should exist", (function () {
	                              return assertExist(get$3(component, gameObjectMap));
	                            }));
	              }), unsafeGet$1(component, gameObjectMap));
	}

	function checkComponentShouldAlive(component, isAliveFunc, state) {
	  return test("component should alive", (function () {
	                return assertTrue(_2(isAliveFunc, component, state));
	              }));
	}

	function generateIndex(index, disposedIndexArray) {
	  var match = disposedIndexArray.pop();
	  if (match !== undefined) {
	    return /* tuple */[
	            match,
	            index
	          ];
	  } else {
	    return /* tuple */[
	            index,
	            index + 1 | 0
	          ];
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _setDefaultChildren(index, childMap) {
	  set$1(index, createEmpty(/* () */0), childMap);
	  return childMap;
	}

	function _setDefaultLocalToWorldMatrix(index, localToWorldMatrixMap, state) {
	  var defaultMatrixArr = /* float array */[
	    1,
	    0,
	    0,
	    0,
	    0,
	    1,
	    0,
	    0,
	    0,
	    0,
	    1,
	    0,
	    0,
	    0,
	    0,
	    1
	  ];
	  var match = getFloat32TypeArrayFromPool(16, state);
	  var defaultMatrixTypeArr = match ? setFloat16(0, defaultMatrixArr, match[0]) : new Float32Array(defaultMatrixArr);
	  set$1(index, defaultMatrixTypeArr, localToWorldMatrixMap);
	  return localToWorldMatrixMap;
	}

	function _setDefaultLocalPosition(index, localPositionMap, state) {
	  var defaultLocalPositionArr = /* float array */[
	    0,
	    0,
	    0
	  ];
	  var match = getFloat32TypeArrayFromPool(3, state);
	  var defaultLocalPositionTypeArr = match ? setFloat3(0, defaultLocalPositionArr, match[0]) : new Float32Array(defaultLocalPositionArr);
	  set$1(index, defaultLocalPositionTypeArr, localPositionMap);
	  return localPositionMap;
	}

	function _initDataWhenCreate(index, childMap, localToWorldMatrixMap, localPositionMap, state) {
	  var match = has$1(index, childMap);
	  if (match !== 0) {
	    return /* () */0;
	  } else {
	    _setDefaultChildren(index, childMap);
	    _setDefaultLocalToWorldMatrix(index, localToWorldMatrixMap, state);
	    _setDefaultLocalPosition(index, localPositionMap, state);
	    return /* () */0;
	  }
	}

	function create$3(state) {
	  var data = getTransformData$2(state);
	  var index = data[/* index */0];
	  var disposedIndexArray = data[/* disposedIndexArray */7];
	  var match = generateIndex(index, disposedIndexArray);
	  var index$1 = match[0];
	  data[/* index */0] = match[1];
	  _initDataWhenCreate(index$1, data[/* childMap */2], data[/* localToWorldMatrixMap */4], data[/* localPositionMap */5], state);
	  return index$1;
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function createIdentityMatrix4() {
	  return new Float32Array(/* float array */[
	              1,
	              0,
	              0,
	              0,
	              0,
	              1,
	              0,
	              0,
	              0,
	              0,
	              1,
	              0,
	              0,
	              0,
	              0,
	              1
	            ]);
	}

	function fromTranslation(positionTypeArr, resultFloat32Arr) {
	  resultFloat32Arr[0] = 1;
	  resultFloat32Arr[1] = 0;
	  resultFloat32Arr[2] = 0;
	  resultFloat32Arr[3] = 0;
	  resultFloat32Arr[4] = 0;
	  resultFloat32Arr[5] = 1;
	  resultFloat32Arr[6] = 0;
	  resultFloat32Arr[7] = 0;
	  resultFloat32Arr[8] = 0;
	  resultFloat32Arr[9] = 0;
	  resultFloat32Arr[10] = 1;
	  resultFloat32Arr[11] = 0;
	  resultFloat32Arr[12] = positionTypeArr[0];
	  resultFloat32Arr[13] = positionTypeArr[1];
	  resultFloat32Arr[14] = positionTypeArr[2];
	  resultFloat32Arr[15] = 1;
	  return resultFloat32Arr;
	}

	function getTranslationTuple(matTypeArr) {
	  return /* tuple */[
	          matTypeArr[12],
	          matTypeArr[13],
	          matTypeArr[14]
	        ];
	}

	function multiply(aMatTypeArr, bMatTypeArr, resultFloat32Arr) {
	  var a00 = aMatTypeArr[0];
	  var a01 = aMatTypeArr[1];
	  var a02 = aMatTypeArr[2];
	  var a03 = aMatTypeArr[3];
	  var a10 = aMatTypeArr[4];
	  var a11 = aMatTypeArr[5];
	  var a12 = aMatTypeArr[6];
	  var a13 = aMatTypeArr[7];
	  var a20 = aMatTypeArr[8];
	  var a21 = aMatTypeArr[9];
	  var a22 = aMatTypeArr[10];
	  var a23 = aMatTypeArr[11];
	  var a30 = aMatTypeArr[12];
	  var a31 = aMatTypeArr[13];
	  var a32 = aMatTypeArr[14];
	  var a33 = aMatTypeArr[15];
	  var b0 = bMatTypeArr[0];
	  var b1 = bMatTypeArr[1];
	  var b2 = bMatTypeArr[2];
	  var b3 = bMatTypeArr[3];
	  resultFloat32Arr[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  resultFloat32Arr[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  resultFloat32Arr[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  resultFloat32Arr[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  b0 = bMatTypeArr[4];
	  b1 = bMatTypeArr[5];
	  b2 = bMatTypeArr[6];
	  b3 = bMatTypeArr[7];
	  resultFloat32Arr[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  resultFloat32Arr[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  resultFloat32Arr[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  resultFloat32Arr[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  b0 = bMatTypeArr[8];
	  b1 = bMatTypeArr[9];
	  b2 = bMatTypeArr[10];
	  b3 = bMatTypeArr[11];
	  resultFloat32Arr[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  resultFloat32Arr[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  resultFloat32Arr[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  resultFloat32Arr[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  b0 = bMatTypeArr[12];
	  b1 = bMatTypeArr[13];
	  b2 = bMatTypeArr[14];
	  b3 = bMatTypeArr[15];
	  resultFloat32Arr[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  resultFloat32Arr[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  resultFloat32Arr[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  resultFloat32Arr[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  return resultFloat32Arr;
	}

	function buildPerspective(fovy, aspect, near, far, resultFloat32Arr) {
	  requireCheck((function () {
	          return test("frustum shouldn't be null", (function () {
	                        var fovy$1 = Math.PI * fovy / 180 / 2;
	                        return Operators[/* <>=. */4](Math.sin(fovy$1), 0);
	                      }));
	        }));
	  var fovy$1 = Math.PI * fovy / 180 / 2;
	  var s = Math.sin(fovy$1);
	  var rd = 1 / (far - near);
	  var ct = Math.cos(fovy$1) / s;
	  resultFloat32Arr[0] = ct / aspect;
	  resultFloat32Arr[1] = 0;
	  resultFloat32Arr[2] = 0;
	  resultFloat32Arr[3] = 0;
	  resultFloat32Arr[4] = 0;
	  resultFloat32Arr[5] = ct;
	  resultFloat32Arr[6] = 0;
	  resultFloat32Arr[7] = 0;
	  resultFloat32Arr[8] = 0;
	  resultFloat32Arr[9] = 0;
	  resultFloat32Arr[10] = -(far + near) * rd;
	  resultFloat32Arr[11] = -1;
	  resultFloat32Arr[12] = 0;
	  resultFloat32Arr[13] = 0;
	  resultFloat32Arr[14] = -2 * far * near * rd;
	  resultFloat32Arr[15] = 0;
	  return /* () */0;
	}

	function invert(mat, resultFloat32Arr) {
	  var a00 = mat[0];
	  var a01 = mat[1];
	  var a02 = mat[2];
	  var a03 = mat[3];
	  var a10 = mat[4];
	  var a11 = mat[5];
	  var a12 = mat[6];
	  var a13 = mat[7];
	  var a20 = mat[8];
	  var a21 = mat[9];
	  var a22 = mat[10];
	  var a23 = mat[11];
	  var a30 = mat[12];
	  var a31 = mat[13];
	  var a32 = mat[14];
	  var a33 = mat[15];
	  var b00 = a00 * a11 - a01 * a10;
	  var b01 = a00 * a12 - a02 * a10;
	  var b02 = a00 * a13 - a03 * a10;
	  var b03 = a01 * a12 - a02 * a11;
	  var b04 = a01 * a13 - a03 * a11;
	  var b05 = a02 * a13 - a03 * a12;
	  var b06 = a20 * a31 - a21 * a30;
	  var b07 = a20 * a32 - a22 * a30;
	  var b08 = a20 * a33 - a23 * a30;
	  var b09 = a21 * a32 - a22 * a31;
	  var b10 = a21 * a33 - a23 * a31;
	  var b11 = a22 * a33 - a23 * a32;
	  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	  var match = det;
	  if (match !== 0) {
	    det = 1.0 / det;
	    resultFloat32Arr[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    resultFloat32Arr[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    resultFloat32Arr[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    resultFloat32Arr[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    resultFloat32Arr[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    resultFloat32Arr[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    resultFloat32Arr[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    resultFloat32Arr[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    resultFloat32Arr[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    resultFloat32Arr[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    resultFloat32Arr[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    resultFloat32Arr[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    resultFloat32Arr[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    resultFloat32Arr[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    resultFloat32Arr[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    resultFloat32Arr[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	    return resultFloat32Arr;
	  } else {
	    return throwMessage("det shouldn't be 0.");
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _transformMat4ToTuple(x, y, z, mat4) {
	  var w = mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15];
	  var d = w;
	  w = d !== 0 ? d : 1.0;
	  return /* tuple */[
	          (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]) / w,
	          (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]) / w,
	          (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]) / w
	        ];
	}

	function transformMat4Tuple(param, mat4) {
	  return _transformMat4ToTuple(param[0], param[1], param[2], mat4);
	}

	function add$1(_, param, param$1) {
	  return /* tuple */[
	          param[0] + param$1[0],
	          param[1] + param$1[1],
	          param[2] + param$1[2]
	        ];
	}

	function sub$1(_, param, param$1) {
	  return /* tuple */[
	          param[0] - param$1[0],
	          param[1] - param$1[1],
	          param[2] - param$1[2]
	        ];
	}

	function lerp(param, param$1, t) {
	  var z1 = param[2];
	  var y1 = param[1];
	  var x1 = param[0];
	  return /* tuple */[
	          x1 + t * (param$1[0] - x1),
	          y1 + t * (param$1[1] - y1),
	          z1 + t * (param$1[2] - z1)
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGlobalTempData(state) {
	  return state[/* globalTempData */25];
	}

	function restore$9(currentState, targetState) {
	  var match = currentState[/* globalTempData */25];
	  var float32Array1 = match[/* float32Array1 */0];
	  var newrecord = targetState.slice();
	  newrecord[/* globalTempData */25] = /* record */[/* float32Array1 */float32Array1];
	  return newrecord;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getFloat32Array1(state) {
	  return getGlobalTempData(state)[/* float32Array1 */0];
	}

	var restore$8 = restore$9;


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getLocalToWorldMatrixTypeArray$2(transform, localToWorlMatrixMap) {
	  return ensureCheck((function () {
	                return test("localToWorldMatrix should exist", (function () {
	                              return assertExist(get$3(transform, localToWorlMatrixMap));
	                            }));
	              }), unsafeGet$1(transform, localToWorlMatrixMap));
	}

	function getLocalPositionTypeArray$1(transform, localPositionMap) {
	  return ensureCheck((function () {
	                return test("localPositionshould exist", (function () {
	                              return assertExist(get$3(transform, localPositionMap));
	                            }));
	              }), unsafeGet$1(transform, localPositionMap));
	}

	function getLocalPositionTuple$1(transform, localPositionMap) {
	  var typeArr = getLocalPositionTypeArray$1(transform, localPositionMap);
	  return /* tuple */[
	          typeArr[0],
	          typeArr[1],
	          typeArr[2]
	        ];
	}

	function setLocalPositionByTuple$1(transform, param, data) {
	  var typeArr = getLocalPositionTypeArray$1(transform, data[/* localPositionMap */5]);
	  typeArr[0] = param[0];
	  typeArr[1] = param[1];
	  typeArr[2] = param[2];
	  return data;
	}

	function update$1(transform, state) {
	  var data = getTransformData$2(state);
	  var localPositionMap = data[/* localPositionMap */5];
	  var localToWorldMatrixMap = data[/* localToWorldMatrixMap */4];
	  var match = isDirty(transform, data);
	  if (match !== 0) {
	    mark(transform, /* false */0, data);
	    var match$1 = getParent$1(transform, data);
	    if (match$1) {
	      var parent = match$1[0];
	      var state$1 = update$1(parent, state);
	      multiply(getLocalToWorldMatrixTypeArray$2(parent, localToWorldMatrixMap), fromTranslation(getLocalPositionTypeArray$1(transform, localPositionMap), getFloat32Array1(state$1)), getLocalToWorldMatrixTypeArray$2(transform, localToWorldMatrixMap));
	      return state$1;
	    } else {
	      fromTranslation(getLocalPositionTypeArray$1(transform, localPositionMap), getLocalToWorldMatrixTypeArray$2(transform, localToWorldMatrixMap));
	      return state;
	    }
	  } else {
	    return state;
	  }
	}

	function getPositionTuple$1(transform, state) {
	  var match = getTransformData$2(update$1(transform, state));
	  return getTranslationTuple(getLocalToWorldMatrixTypeArray$2(transform, match[/* localToWorldMatrixMap */4]));
	}

	function setPositionByTuple$1(transform, position, data, state) {
	  var match = getParent$1(transform, data);
	  if (match) {
	    var parent = match[0];
	    var data$1 = getTransformData$2(update$1(parent, state));
	    setLocalPositionByTuple$1(transform, transformMat4Tuple(position, invert(getLocalToWorldMatrixTypeArray$2(parent, data$1[/* localToWorldMatrixMap */4]), getFloat32Array1(state))), data$1);
	    return data$1;
	  } else {
	    setLocalPositionByTuple$1(transform, position, data);
	    return data;
	  }
	}


	/* TransformDirtyCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGameObject$1(transform, transformData) {
	  return getComponentGameObject(transform, transformData[/* gameObjectMap */3]);
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleAddComponent$1(transform, gameObjectUid, state) {
	  var transformData = getTransformData$2(state);
	  addComponentToGameObjectMap(transform, gameObjectUid, transformData[/* gameObjectMap */3]);
	  return state;
	}


	/* TransformStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isAlive$3(component, disposedIndexArray) {
	  return 1 - +disposedIndexArray.includes(component);
	}

	function checkComponentShouldAlive$1(component, isAlive, state) {
	  return test("shouldn't dispose the component which isn't alive", (function () {
	                return assertTrue(_2(isAlive, component, state));
	              }));
	}

	var disposeSparseMapData = deleteVal$1;

	function removeFromArray(target, arr) {
	  var index = arr.indexOf(target);
	  var lastIndex = arr.length - 1 | 0;
	  deleteBySwap(index, lastIndex, arr);
	  return arr;
	}

	function batchRemoveFromArray(disposedMap, arr) {
	  return arr.filter((function (value) {
	                return +(has$1(value, disposedMap) === /* false */0);
	              }));
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isAlive$2(transform, state) {
	  return isAlive$3(transform, getTransformData$2(state)[/* disposedIndexArray */7]);
	}

	function _disposeFromParentAndChildMap(transform, data) {
	  forEach((function (child) {
	          removeFromParentMap(child, data);
	          return /* () */0;
	        }), unsafeGetChildren$1(transform, data));
	  var match = getParent$1(transform, data);
	  if (match) {
	    removeFromChildMap(match[0], transform, data);
	  }
	  return data;
	}

	function _disposeData(transform, state) {
	  var data = getTransformData$2(state);
	  var localPositionMap = data[/* localPositionMap */5];
	  var localToWorldMatrixMap = data[/* localToWorldMatrixMap */4];
	  _disposeFromParentAndChildMap(transform, data);
	  var state$1 = addTypeArrayToPool(transform, getMaxTypeArrayPoolSize(state), localToWorldMatrixMap, localPositionMap, state);
	  disposeSparseMapData(transform, localToWorldMatrixMap);
	  disposeSparseMapData(transform, localPositionMap);
	  disposeSparseMapData(transform, data[/* parentMap */1]);
	  disposeSparseMapData(transform, data[/* childMap */2]);
	  disposeSparseMapData(transform, data[/* dirtyMap */6]);
	  disposeSparseMapData(transform, data[/* gameObjectMap */3]);
	  return state$1;
	}

	function handleDisposeComponent(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, state);
	        }));
	  var data = getTransformData$2(state);
	  var disposedIndexArray = data[/* disposedIndexArray */7];
	  disposedIndexArray.push(transform);
	  return _disposeData(transform, state);
	}

	function handleBatchDisposeComponent(transformArray, _, state) {
	  requireCheck((function () {
	          return forEach((function (transform) {
	                        return checkComponentShouldAlive$1(transform, isAlive$2, state);
	                      }), transformArray);
	        }));
	  var data = getTransformData$2(state);
	  var disposedIndexArray = data[/* disposedIndexArray */7];
	  data[/* disposedIndexArray */7] = disposedIndexArray.concat(transformArray);
	  forEach((function (transform) {
	          return _disposeData(transform, state);
	        }), transformArray);
	  return state;
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var isAlive$1 = isAlive$2;

	function getLocalToWorldMatrixTypeArray$1(transform, state) {
	  var match = getTransformData$2(update$1(transform, state));
	  return getLocalToWorldMatrixTypeArray$2(transform, match[/* localToWorldMatrixMap */4]);
	}

	function create$2(state) {
	  var data = getTransformData$2(state);
	  var index = create$3(state);
	  mark(index, /* false */0, data);
	  return /* tuple */[
	          state,
	          index
	        ];
	}

	function getParent(child, state) {
	  return getParent$1(child, getTransformData$2(state));
	}

	var setParentNotMarkDirty = setParent$1;

	function setParent(parent, child, state) {
	  var transformData = getTransformData$2(state);
	  markHierachyDirty(child, setParent$1((parent == null) ? /* None */0 : [parent], child, transformData));
	  return state;
	}

	function getChildren(transform, state) {
	  return unsafeGetChildren$1(transform, getTransformData$2(state)).slice();
	}

	var unsafeGetChildren = unsafeGetChildren$1;

	function getLocalPositionTuple(transform, state) {
	  return getLocalPositionTuple$1(transform, getTransformData$2(state)[/* localPositionMap */5]);
	}

	function setLocalPositionByTuple(transform, localPosition, state) {
	  markHierachyDirty(transform, setLocalPositionByTuple$1(transform, localPosition, getTransformData$2(state)));
	  return state;
	}

	var getPositionTuple = getPositionTuple$1;

	function setPositionByTuple(transform, position, state) {
	  markHierachyDirty(transform, setPositionByTuple$1(transform, position, getTransformData$2(state), state));
	  return state;
	}

	function getGameObject(transform, state) {
	  return getGameObject$1(transform, getTransformData$2(state));
	}

	var getTransformData$1 = getTransformData$2;

	var deepCopyStateForRestore$7 = deepCopyStateForRestore$8;

	var restore$5 = restore$6;


	/* TransformDirtyCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var getLocalToWorldMatrixTypeArray = getLocalToWorldMatrixTypeArray$1;

	var getTransformData = getTransformData$1;

	var deepCopyStateForRestore$6 = deepCopyStateForRestore$7;

	var restore$4 = restore$5;


	/* TransformSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getMaterialData(state) {
	  return getExn(state[/* materialData */13]);
	}

	function deepCopyStateForRestore$10(state) {
	  var match = getExn(state[/* materialData */13]);
	  var index = match[/* index */0];
	  var disposedIndexArray = match[/* disposedIndexArray */5];
	  var newrecord = state.slice();
	  newrecord[/* materialData */13] = /* Some */[/* record */[
	      /* index */index,
	      /* shaderIndexMap : int array */[],
	      /* colorMap */copy$1(match[/* colorMap */2]),
	      /* gameObjectMap */copy$1(match[/* gameObjectMap */3]),
	      /* groupCountMap */copy$1(match[/* groupCountMap */4]),
	      /* disposedIndexArray */disposedIndexArray.slice()
	    ]];
	  return newrecord;
	}

	function restore$10(_, targetState) {
	  var newrecord = targetState.slice();
	  var newrecord$1 = getExn(targetState[/* materialData */13]).slice();
	  newrecord[/* materialData */13] = /* Some */[(newrecord$1[/* shaderIndexMap */1] = /* int array */[], newrecord$1)];
	  return newrecord;
	}


	/* SparseMapSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function unsafeGetColor$1(material, state) {
	  return unsafeGet$1(material, getMaterialData(state)[/* colorMap */2]);
	}

	function setColor(material, color, state) {
	  set$1(material, color, getMaterialData(state)[/* colorMap */2]);
	  return state;
	}


	/* MaterialStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var unsafeGetColor = unsafeGetColor$1;


	/* MaterialOperateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getCameraVMatrixDataFromState(state) {
	  return getExn(state[/* renderData */21][/* cameraData */1])[/* vMatrix */0];
	}

	function getCameraPMatrixDataFromState(state) {
	  return getExn(state[/* renderData */21][/* cameraData */1])[/* pMatrix */1];
	}

	function getRenderArrayFromState(state) {
	  return state[/* renderData */21][/* renderArray */0];
	}

	function setRenderArray(renderArray, state) {
	  var match = renderArray.length;
	  state[/* renderData */21][/* renderArray */0] = match !== 0 ? /* Some */[renderArray] : /* None */0;
	  return /* () */0;
	}

	function setCameraData(cameraData, state) {
	  state[/* renderData */21][/* cameraData */1] = cameraData;
	  return /* () */0;
	}

	function restore$11(_, targetState) {
	  var newrecord = targetState.slice();
	  newrecord[/* renderData */21] = /* record */[
	    /* renderArray : None */0,
	    /* cameraData : None */0
	  ];
	  return newrecord;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getAttribLocation(program, name, attributeLocationMap, gl) {
	  var match = get$2(name, attributeLocationMap);
	  if (match) {
	    return match[0];
	  } else {
	    var pos = gl.getAttribLocation(program, name);
	    set(name, pos, attributeLocationMap);
	    return pos;
	  }
	}

	function getUniformLocation(program, name, uniformLocationMap, gl) {
	  var match = get$2(name, uniformLocationMap);
	  if (match) {
	    return match[0];
	  } else {
	    var pos = gl.getUniformLocation(program, name);
	    set(name, pos, uniformLocationMap);
	    return pos;
	  }
	}

	function getAttributeLocationMap(shaderIndex, state) {
	  return get$3(shaderIndex, state[/* glslLocationData */18][/* attributeLocationMap */0]);
	}

	function setAttributeLocationMap(shaderIndex, attributeLocationMap, state) {
	  set$1(shaderIndex, attributeLocationMap, state[/* glslLocationData */18][/* attributeLocationMap */0]);
	  return state;
	}

	function getUniformLocationMap(shaderIndex, state) {
	  return get$3(shaderIndex, state[/* glslLocationData */18][/* uniformLocationMap */1]);
	}

	function setUniformLocationMap(shaderIndex, uniformLocationMap, state) {
	  set$1(shaderIndex, uniformLocationMap, state[/* glslLocationData */18][/* uniformLocationMap */1]);
	  return state;
	}

	function deepCopyStateForRestore$11(state) {
	  return state;
	}

	function restore$12(intersectShaderIndexDataArray, currentState, targetState) {
	  var match = currentState[/* glslLocationData */18];
	  var newrecord = targetState.slice();
	  newrecord[/* glslLocationData */18] = /* record */[
	    /* attributeLocationMap */getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* attributeLocationMap */0]),
	    /* uniformLocationMap */getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* uniformLocationMap */1])
	  ];
	  return newrecord;
	}


	/* HashMapSystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGLSLSenderData(state) {
	  return state[/* glslSenderData */19];
	}

	function deepCopyStateForRestore$12(state) {
	  return state;
	}

	function restore$13(intersectShaderIndexDataArray, currentState, targetState) {
	  var match = currentState[/* glslSenderData */19];
	  var newrecord = targetState.slice();
	  newrecord[/* glslSenderData */19] = /* record */[
	    /* attributeSendDataMap */getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* attributeSendDataMap */0]),
	    /* instanceAttributeSendDataMap */getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* instanceAttributeSendDataMap */1]),
	    /* uniformCacheMap */getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* uniformCacheMap */2]),
	    /* uniformSendNoCacheableDataMap */getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* uniformSendNoCacheableDataMap */3]),
	    /* uniformSendCacheableDataMap */getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* uniformSendCacheableDataMap */4]),
	    /* shaderUniformSendNoCacheableDataMap */getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* shaderUniformSendNoCacheableDataMap */5]),
	    /* instanceUniformSendNoCacheableDataMap */getIntersectShaderRelatedMap(intersectShaderIndexDataArray, match[/* instanceUniformSendNoCacheableDataMap */6]),
	    /* vertexAttribHistoryArray */createEmpty(/* () */0),
	    /* lastSendArrayBuffer : None */0,
	    /* lastSendElementArrayBuffer : None */0,
	    /* lastSendMaterial : None */0
	  ];
	  return newrecord;
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function bindElementArrayBuffer(gl, _, _$1, buffer, state) {
	  var data = getGLSLSenderData(state);
	  var lastSendElementArrayBuffer = data[/* lastSendElementArrayBuffer */9];
	  var exit = 0;
	  if (lastSendElementArrayBuffer) {
	    if (lastSendElementArrayBuffer[0] === buffer) {
	      return state;
	    } else {
	      exit = 1;
	    }
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    data[/* lastSendElementArrayBuffer */9] = /* Some */[buffer];
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
	    return state;
	  }
	  
	}

	function drawElement(drawMode, type_, _, indicesCount, gl) {
	  gl.drawElements(drawMode, indicesCount, type_, 0);
	  return /* () */0;
	}

	function drawElementsInstancedANGLE(drawMode, type_, _, indicesCount, instancesCount, extension) {
	  extension.drawElementsInstancedANGLE(drawMode, indicesCount, type_, 0, instancesCount);
	  return /* () */0;
	}


	/* GLSLSenderStateUtils-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getBufferSizeByType(type_) {
	  if (type_ === "vec3") {
	    return 3;
	  } else {
	    return throwMessage("invalide type_:" + (String(type_) + ""));
	  }
	}

	function sendBuffer(gl, size, pos, buffer, state) {
	  var data = getGLSLSenderData(state);
	  var vertexAttribHistoryArray = data[/* vertexAttribHistoryArray */7];
	  var lastSendArrayBuffer = data[/* lastSendArrayBuffer */8];
	  var exit = 0;
	  if (lastSendArrayBuffer) {
	    if (lastSendArrayBuffer[0] === buffer) {
	      return state;
	    } else {
	      exit = 1;
	    }
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    data[/* lastSendArrayBuffer */8] = /* Some */[buffer];
	    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	    gl.vertexAttribPointer(pos, size, gl.FLOAT, false, 0, 0);
	    var match = isNotEqual(pos, /* true */1, vertexAttribHistoryArray);
	    if (match !== 0) {
	      gl.enableVertexAttribArray(pos);
	      vertexAttribHistoryArray[pos] = /* true */1;
	      return state;
	    } else {
	      return state;
	    }
	  }
	  
	}

	function sendMatrix4(gl, pos, data) {
	  gl.uniformMatrix4fv(pos, false, data);
	  return /* () */0;
	}

	function getCacheMap(shaderIndex, param) {
	  return get$3(shaderIndex, param[/* uniformCacheMap */2]);
	}

	function _isNotCacheVector3(shaderCacheMap, name, x, y, z) {
	  var match = get$2(name, shaderCacheMap);
	  if (match) {
	    var cache = match[0];
	    var isNotCached = /* false */0;
	    if (cache[0] !== x) {
	      cache[0] = x;
	      isNotCached = /* true */1;
	    }
	    if (cache[1] !== y) {
	      cache[1] = y;
	      isNotCached = /* true */1;
	    }
	    if (cache[2] !== z) {
	      cache[2] = z;
	      isNotCached = /* true */1;
	    }
	    return isNotCached;
	  } else {
	    set(name, /* float array */[
	          x,
	          y,
	          z
	        ], shaderCacheMap);
	    return /* true */1;
	  }
	}

	function sendFloat3(gl, shaderCacheMap, name, pos, param) {
	  if (param.length !== 3) {
	    throw [
	          match_failure,
	          [
	            "/Users/y/Github/Wonder.js/src/renderer/shader/sender/utils/GLSLSenderSendDataUtils.re",
	            77,
	            2
	          ]
	        ];
	  } else {
	    var x = param[0];
	    var y = param[1];
	    var z = param[2];
	    if (_isNotCacheVector3(shaderCacheMap, name, x, y, z)) {
	      gl.uniform3f(pos, x, y, z);
	      return /* () */0;
	    } else {
	      return /* () */0;
	    }
	  }
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _getOrCreateHashMap(map) {
	  if (map) {
	    return map[0];
	  } else {
	    return createEmpty$1(/* () */0);
	  }
	}

	function addAttributeSendData(gl, shaderIndex, program, shaderLibDataArr, state) {
	  requireCheck((function () {
	          return test("shouldn't be added before", (function () {
	                        return assertNotExist(get$3(shaderIndex, getGLSLSenderData(state)[/* attributeSendDataMap */0]));
	                      }));
	        }));
	  var attributeLocationMap = _getOrCreateHashMap(getAttributeLocationMap(shaderIndex, state));
	  var sendDataArr = createEmpty(/* () */0);
	  var instanceSendNoCacheableDataArr = createEmpty(/* () */0);
	  forEach((function (param) {
	          var variables = param[/* variables */2];
	          if (variables) {
	            var attributes = variables[0][/* attributes */1];
	            if (attributes) {
	              return forEach((function (param) {
	                            var type_ = param[/* type_ */2];
	                            var buffer = param[/* buffer */1];
	                            var name = param[/* name */0];
	                            var exit = 0;
	                            if (name) {
	                              if (type_) {
	                                var name$1 = name[0];
	                                if (buffer === "instance") {
	                                  instanceSendNoCacheableDataArr.push(/* record */[/* pos */getAttribLocation(program, name$1, attributeLocationMap, gl)]);
	                                  return /* () */0;
	                                } else {
	                                  sendDataArr.push(/* record */[
	                                        /* pos */getAttribLocation(program, name$1, attributeLocationMap, gl),
	                                        /* size */getBufferSizeByType(type_[0]),
	                                        /* buffer */buffer,
	                                        /* sendFunc */sendBuffer
	                                      ]);
	                                  return /* () */0;
	                                }
	                              } else {
	                                exit = 1;
	                              }
	                            } else {
	                              exit = 1;
	                            }
	                            if (exit === 1) {
	                              sendDataArr.push(/* record */[
	                                    /* pos */0,
	                                    /* size */0,
	                                    /* buffer */buffer,
	                                    /* sendFunc */bindElementArrayBuffer
	                                  ]);
	                              return /* () */0;
	                            }
	                            
	                          }), attributes[0]);
	            } else {
	              return /* () */0;
	            }
	          } else {
	            return /* () */0;
	          }
	        }), shaderLibDataArr);
	  var match = getGLSLSenderData(state);
	  set$1(shaderIndex, sendDataArr, match[/* attributeSendDataMap */0]);
	  set$1(shaderIndex, instanceSendNoCacheableDataArr, match[/* instanceAttributeSendDataMap */1]);
	  return setAttributeLocationMap(shaderIndex, attributeLocationMap, state);
	}

	var _getModelMNoCacheableData = getLocalToWorldMatrixTypeArray;

	function _addUniformSendDataByType(sendNoCacheableDataArr, sendCacheableDataArr, type_, shaderCacheMap, name, pos, getDataFunc) {
	  switch (type_) {
	    case "mat4" : 
	        sendNoCacheableDataArr.push(/* record */[
	              /* pos */pos,
	              /* getNoCacheableDataFunc */getDataFunc,
	              /* sendNoCacheableDataFunc */sendMatrix4
	            ]);
	        return /* () */0;
	    case "vec3" : 
	        sendCacheableDataArr.push(/* record */[
	              /* shaderCacheMap */shaderCacheMap,
	              /* name */name,
	              /* pos */pos,
	              /* getCacheableDataFunc */getDataFunc,
	              /* sendCacheableDataFunc */sendFloat3
	            ]);
	        return /* () */0;
	    default:
	      return throwMessage("unknow type:" + (String(type_) + ""));
	  }
	}

	function _addShaderUniformSendDataByType(sendNoCacheableDataArr, type_, pos, getDataFunc) {
	  if (type_ === "mat4") {
	    sendNoCacheableDataArr.push(/* record */[
	          /* pos */pos,
	          /* getNoCacheableDataFunc */getDataFunc,
	          /* sendNoCacheableDataFunc */sendMatrix4
	        ]);
	    return /* () */0;
	  } else {
	    return throwMessage("unknow type:" + (String(type_) + ""));
	  }
	}

	function _addInstanceUniformSendDataByType(sendNoCacheableDataArr, type_, pos, getDataFunc) {
	  if (type_ === "mat4") {
	    sendNoCacheableDataArr.push(/* record */[
	          /* pos */pos,
	          /* getNoCacheableDataFunc */getDataFunc,
	          /* sendNoCacheableDataFunc */sendMatrix4
	        ]);
	    return /* () */0;
	  } else {
	    return throwMessage("unknow type:" + (String(type_) + ""));
	  }
	}

	function addUniformSendData(gl, shaderIndex, program, shaderLibDataArr, state) {
	  requireCheck((function () {
	          return test("shouldn't be added before", (function () {
	                        return assertNotExist(get$3(shaderIndex, getGLSLSenderData(state)[/* uniformSendNoCacheableDataMap */3]));
	                      }));
	        }));
	  var data = getGLSLSenderData(state);
	  var uniformLocationMap = _getOrCreateHashMap(getUniformLocationMap(shaderIndex, state));
	  var uniformCacheMap = _getOrCreateHashMap(getCacheMap(shaderIndex, data));
	  var sendNoCacheableDataArr = createEmpty(/* () */0);
	  var sendCacheableDataArr = createEmpty(/* () */0);
	  var shaderSendNoCacheableDataArr = createEmpty(/* () */0);
	  var instanceSendNoCacheableDataArr = createEmpty(/* () */0);
	  forEach((function (param) {
	          var variables = param[/* variables */2];
	          if (variables) {
	            var uniforms = variables[0][/* uniforms */0];
	            if (uniforms) {
	              return forEach((function (param) {
	                            var from = param[/* from */3];
	                            var type_ = param[/* type_ */2];
	                            var field = param[/* field */1];
	                            var name = param[/* name */0];
	                            var pos = getUniformLocation(program, name, uniformLocationMap, gl);
	                            switch (from) {
	                              case "camera" : 
	                                  switch (field) {
	                                    case "pMatrix" : 
	                                        return _addShaderUniformSendDataByType(shaderSendNoCacheableDataArr, type_, pos, getCameraPMatrixDataFromState);
	                                    case "vMatrix" : 
	                                        return _addShaderUniformSendDataByType(shaderSendNoCacheableDataArr, type_, pos, getCameraVMatrixDataFromState);
	                                    default:
	                                      return throwMessage("unknow field:" + (String(field) + ""));
	                                  }
	                                  break;
	                              case "material" : 
	                                  if (field === "color") {
	                                    return _addUniformSendDataByType(sendNoCacheableDataArr, sendCacheableDataArr, type_, uniformCacheMap, name, pos, unsafeGetColor);
	                                  } else {
	                                    return throwMessage("unknow field:" + (String(field) + ""));
	                                  }
	                                  break;
	                              case "model" : 
	                                  switch (field) {
	                                    case "instance_mMatrix" : 
	                                        return _addInstanceUniformSendDataByType(instanceSendNoCacheableDataArr, type_, pos, _getModelMNoCacheableData);
	                                    case "mMatrix" : 
	                                        return _addUniformSendDataByType(sendNoCacheableDataArr, sendCacheableDataArr, type_, uniformCacheMap, name, pos, _getModelMNoCacheableData);
	                                    default:
	                                      return throwMessage("unknow field:" + (String(field) + ""));
	                                  }
	                                  break;
	                              default:
	                                return throwMessage("unknow from:" + (String(from) + ""));
	                            }
	                          }), uniforms[0]);
	            } else {
	              return /* () */0;
	            }
	          } else {
	            return /* () */0;
	          }
	        }), shaderLibDataArr);
	  set$1(shaderIndex, sendNoCacheableDataArr, data[/* uniformSendNoCacheableDataMap */3]);
	  set$1(shaderIndex, sendCacheableDataArr, data[/* uniformSendCacheableDataMap */4]);
	  set$1(shaderIndex, shaderSendNoCacheableDataArr, data[/* shaderUniformSendNoCacheableDataMap */5]);
	  set$1(shaderIndex, instanceSendNoCacheableDataArr, data[/* instanceUniformSendNoCacheableDataMap */6]);
	  return setUniformLocationMap(shaderIndex, uniformLocationMap, state);
	}

	function getAttributeSendData(shaderIndex, state) {
	  var match = getGLSLSenderData(state);
	  return ensureCheck((function () {
	                return test("attribute send data should exist", (function () {
	                              var match = getGLSLSenderData(state);
	                              return assertExist(get$3(shaderIndex, match[/* attributeSendDataMap */0]));
	                            }));
	              }), unsafeGet$1(shaderIndex, match[/* attributeSendDataMap */0]));
	}

	function getInstanceAttributeSendData(shaderIndex, state) {
	  var match = getGLSLSenderData(state);
	  return ensureCheck((function () {
	                return test("instance attribute send data should exist", (function () {
	                              var match = getGLSLSenderData(state);
	                              return assertExist(get$3(shaderIndex, match[/* instanceAttributeSendDataMap */1]));
	                            }));
	              }), unsafeGet$1(shaderIndex, match[/* instanceAttributeSendDataMap */1]));
	}

	function _getUniformSendData(shaderIndex, map) {
	  return ensureCheck((function () {
	                return test("uniform send data should exist", (function () {
	                              return assertExist(get$3(shaderIndex, map));
	                            }));
	              }), unsafeGet$1(shaderIndex, map));
	}

	function getUniformSendNoCacheableData(shaderIndex, state) {
	  return _getUniformSendData(shaderIndex, getGLSLSenderData(state)[/* uniformSendNoCacheableDataMap */3]);
	}

	function getUniformSendCacheableData(shaderIndex, state) {
	  return _getUniformSendData(shaderIndex, getGLSLSenderData(state)[/* uniformSendCacheableDataMap */4]);
	}

	function getShaderUniformSendNoCacheableData(shaderIndex, state) {
	  return _getUniformSendData(shaderIndex, getGLSLSenderData(state)[/* shaderUniformSendNoCacheableDataMap */5]);
	}

	function getInstanceUniformSendNoCacheableData(shaderIndex, state) {
	  return _getUniformSendData(shaderIndex, getGLSLSenderData(state)[/* instanceUniformSendNoCacheableDataMap */6]);
	}


	/* TransformAdmin-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getAllShaderIndexArray(state) {
	  return range(0, getShaderData(state)[/* index */0] - 1 | 0);
	}

	function _genereateShaderIndex(state) {
	  var shaderData = getShaderData(state);
	  var index = shaderData[/* index */0];
	  shaderData[/* index */0] = index + 1 | 0;
	  return /* tuple */[
	          state,
	          index
	        ];
	}

	function _getShaderIndex(key, param) {
	  var shaderIndexMap = param[/* shaderIndexMap */1];
	  return get$2(key, shaderIndexMap);
	}

	function _setShaderIndex(key, shaderIndex, param) {
	  var shaderIndexMap = param[/* shaderIndexMap */1];
	  return set(key, shaderIndex, shaderIndexMap);
	}

	function _join(array) {
	  var output = "";
	  for(var i = 0 ,i_finish = array.length - 1 | 0; i <= i_finish; ++i){
	    output = output + caml_array_get(array, i)[/* name */0];
	  }
	  return output;
	}

	function _init(gl, materialIndex, shaderLibDataArr, buildGLSLSource$$1, state) {
	  var shaderData = getShaderData(state);
	  var key = _join(shaderLibDataArr);
	  var match = _getShaderIndex(key, shaderData);
	  if (match) {
	    return match[0];
	  } else {
	    var match$1 = _genereateShaderIndex(state);
	    var shaderIndex = match$1[1];
	    var state$1 = match$1[0];
	    _setShaderIndex(key, shaderIndex, shaderData);
	    var match$2 = buildGLSLSource$$1(materialIndex, shaderLibDataArr, state$1);
	    var program = initShader(match$2[0], match$2[1], gl, registerProgram(shaderIndex, state$1, createProgram(gl)));
	    addUniformSendData(gl, shaderIndex, program, shaderLibDataArr, addAttributeSendData(gl, shaderIndex, program, shaderLibDataArr, state$1));
	    return shaderIndex;
	  }
	}

	var getPrecisionSource = getPrecisionSource$1;

	var initMaterialShader = _init;

	var getIntersectShaderIndexDataArray = getIntersectShaderIndexDataArray$1;

	var deepCopyStateForRestore$3 = deepCopyStateForRestore$5;

	var restore$1 = restore$3;


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$3(state) {
	  state[/* materialData */13] = /* Some */[/* record */[
	      /* index */0,
	      /* shaderIndexMap */createEmpty$2(/* () */0),
	      /* colorMap */createEmpty$2(/* () */0),
	      /* gameObjectMap */createEmpty$2(/* () */0),
	      /* groupCountMap */createEmpty$2(/* () */0),
	      /* disposedIndexArray */createEmpty(/* () */0)
	    ]];
	  return state;
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGameObject$3(material, state) {
	  return getComponentGameObject(material, getMaterialData(state)[/* gameObjectMap */3]);
	}

	function unsafeGetGameObject(material, state) {
	  return unsafeGetComponentGameObject(material, getMaterialData(state)[/* gameObjectMap */3]);
	}


	/* MaterialStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function unsafeGetShaderIndex$2(materialIndex, state) {
	  return ensureCheck((function () {
	                return test("shaderIndex should exist", (function () {
	                              return assertExist(get$3(materialIndex, getMaterialData(state)[/* shaderIndexMap */1]));
	                            }));
	              }), unsafeGet$1(materialIndex, getMaterialData(state)[/* shaderIndexMap */1]));
	}

	function hasShaderIndex(materialIndex, state) {
	  return has$1(materialIndex, getMaterialData(state)[/* shaderIndexMap */1]);
	}

	function setShaderIndex$1(materialIndex, shaderIndex, state) {
	  set$1(materialIndex, shaderIndex, getMaterialData(state)[/* shaderIndexMap */1]);
	  return state;
	}


	/* MaterialStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function setConfig$1(gpuConfig, state) {
	  var newrecord = state.slice();
	  newrecord[/* gpuConfig */1] = /* Some */[gpuConfig];
	  return newrecord;
	}

	function getConfig$1(state) {
	  return getExn(state[/* gpuConfig */1]);
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGroupCount$1(component, groupCountMap) {
	  var match = get$3(component, groupCountMap);
	  if (match) {
	    return match[0];
	  } else {
	    return 0;
	  }
	}

	function isGroupComponent(component, groupCountMap) {
	  return +(getGroupCount$1(component, groupCountMap) > 0);
	}

	function increaseGroupCount$1(component, groupCountMap) {
	  return set$1(component, getGroupCount$1(component, groupCountMap) + 1 | 0, groupCountMap);
	}

	function decreaseGroupCount$1(component, groupCountMap) {
	  return set$1(component, getGroupCount$1(component, groupCountMap) - 1 | 0, groupCountMap);
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGeometryData(state) {
	  return getExn(state[/* geometryData */14]);
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isGroupGeometry(geometry, state) {
	  return isGroupComponent(geometry, getGeometryData(state)[/* groupCountMap */8]);
	}

	function increaseGroupCount(geometry, state) {
	  increaseGroupCount$1(geometry, getGeometryData(state)[/* groupCountMap */8]);
	  return state;
	}

	function decreaseGroupCount(geometry, state) {
	  decreaseGroupCount$1(geometry, getGeometryData(state)[/* groupCountMap */8]);
	  return state;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isGroupMaterial(material, state) {
	  return isGroupComponent(material, getMaterialData(state)[/* groupCountMap */4]);
	}

	function increaseGroupCount$2(material, state) {
	  increaseGroupCount$1(material, getMaterialData(state)[/* groupCountMap */4]);
	  return state;
	}

	function decreaseGroupCount$2(material, state) {
	  decreaseGroupCount$1(material, getMaterialData(state)[/* groupCountMap */4]);
	  return state;
	}


	/* MaterialStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGameObjectData(state) {
	  return state[/* gameObjectData */10];
	}

	function deepCopyStateForRestore$14(state) {
	  var match = state[/* gameObjectData */10];
	  var uid = match[/* uid */0];
	  var disposeCount = match[/* disposeCount */1];
	  var disposedUidMap = match[/* disposedUidMap */2];
	  var aliveUidArray = match[/* aliveUidArray */3];
	  var transformMap = match[/* transformMap */4];
	  var cameraControllerMap = match[/* cameraControllerMap */5];
	  var geometryMap = match[/* geometryMap */6];
	  var meshRendererMap = match[/* meshRendererMap */7];
	  var materialMap = match[/* materialMap */8];
	  var sourceInstanceMap = match[/* sourceInstanceMap */9];
	  var objectInstanceMap = match[/* objectInstanceMap */10];
	  var newrecord = state.slice();
	  newrecord[/* gameObjectData */10] = /* record */[
	    /* uid */uid,
	    /* disposeCount */disposeCount,
	    /* disposedUidMap */copy$1(disposedUidMap),
	    /* aliveUidArray */copy$1(aliveUidArray),
	    /* transformMap */copy$1(transformMap),
	    /* cameraControllerMap */copy$1(cameraControllerMap),
	    /* geometryMap */copy$1(geometryMap),
	    /* meshRendererMap */copy$1(meshRendererMap),
	    /* materialMap */copy$1(materialMap),
	    /* sourceInstanceMap */copy$1(sourceInstanceMap),
	    /* objectInstanceMap */copy$1(objectInstanceMap)
	  ];
	  return newrecord;
	}


	/* SparseMapSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGameObject$4(geometry, state) {
	  return getComponentGameObject(geometry, getGeometryData(state)[/* gameObjectMap */5]);
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleAddComponent$2(geometry, gameObjectUid, state) {
	  var geometryData = getGeometryData(state);
	  addComponentToGameObjectMap(geometry, gameObjectUid, geometryData[/* gameObjectMap */5]);
	  return state;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleAddComponent$3(material, gameObjectUid, state) {
	  var match = getMaterialData(state);
	  addComponentToGameObjectMap(material, gameObjectUid, match[/* gameObjectMap */3]);
	  return state;
	}


	/* MaterialStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleCloneComponent(sourceComponent, countRangeArr, state) {
	  return /* tuple */[
	          state,
	          countRangeArr.map((function () {
	                  return sourceComponent;
	                }))
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isBasicMaterial(_, _$1) {
	  return /* true */1;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _setDefaultColor(index, colorMap) {
	  set$1(index, /* float array */[
	        1,
	        1,
	        1
	      ], colorMap);
	  return colorMap;
	}

	function create$5(state) {
	  var data = getMaterialData(state);
	  var index = data[/* index */0];
	  var disposedIndexArray = data[/* disposedIndexArray */5];
	  var match = generateIndex(index, disposedIndexArray);
	  var index$1 = match[0];
	  data[/* index */0] = match[1];
	  _setDefaultColor(index$1, data[/* colorMap */2]);
	  return /* tuple */[
	          state,
	          index$1
	        ];
	}


	/* MaterialStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function create$4(state) {
	  var match = create$5(state);
	  return /* tuple */[
	          match[0],
	          match[1]
	        ];
	}


	/* MaterialCreateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleCloneComponent$1(sourceComponent, countRangeArr, isShareMaterial, state) {
	  if (isShareMaterial !== 0) {
	    return /* tuple */[
	            state,
	            countRangeArr.map((function () {
	                    return sourceComponent;
	                  }))
	          ];
	  } else {
	    var hasShaderIndex$$1 = hasShaderIndex(sourceComponent, state);
	    var shaderIndex = hasShaderIndex$$1 !== 0 ? unsafeGetShaderIndex$2(sourceComponent, state) : -1;
	    var createFunc = isBasicMaterial(sourceComponent, state) ? create$4 : throwMessage("unknown material:" + (String(sourceComponent) + ""));
	    var color = unsafeGetColor$1(sourceComponent, state);
	    var componentArr = /* int array */[];
	    var state$1 = reduceState((function (state, _) {
	            var match = _1(createFunc, state);
	            var index = match[1];
	            componentArr.push(index);
	            var state$1 = setColor(index, color, match[0]);
	            if (hasShaderIndex$$1 !== 0) {
	              return setShaderIndex$1(index, shaderIndex, state$1);
	            } else {
	              return state$1;
	            }
	          }), state, countRangeArr);
	    return /* tuple */[
	            state$1,
	            componentArr
	          ];
	  }
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleCloneComponent$2(sourceComponent, countRangeArr, state) {
	  var componentArr = /* array */[];
	  var data = getTransformData$2(state);
	  var localPosition = getLocalPositionTuple$1(sourceComponent, data[/* localPositionMap */5]);
	  var state$1 = reduceState((function (state, _) {
	          var index = create$3(state);
	          mark(index, /* true */1, setLocalPositionByTuple$1(index, localPosition, data));
	          componentArr.push(index);
	          return state;
	        }), state, countRangeArr);
	  mark(sourceComponent, /* true */1, data);
	  return /* tuple */[
	          state$1,
	          componentArr
	        ];
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getVboBufferData(state) {
	  return state[/* vboBufferData */24];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _getBufferAndSetBufferMap(gl, bufferPool) {
	  var match = bufferPool.pop();
	  if (match !== undefined) {
	    return match;
	  } else {
	    return gl.createBuffer();
	  }
	}

	function getArrayBuffer(gl, state) {
	  var match = getVboBufferData(state);
	  return _getBufferAndSetBufferMap(gl, match[/* vertexArrayBufferPool */3]);
	}

	function getElementArrayBuffer(gl, state) {
	  var match = getVboBufferData(state);
	  return _getBufferAndSetBufferMap(gl, match[/* elementArrayBufferPool */4]);
	}

	function getInstanceBuffer(gl, state) {
	  var match = getVboBufferData(state);
	  return _getBufferAndSetBufferMap(gl, match[/* modelMatrixInstanceBufferPool */5]);
	}

	function _unsafeGetBufferFromBufferMap(index, bufferMap) {
	  return ensureCheck((function () {
	                return test("buffer should exist in bufferMap", (function () {
	                              return assertTrue(has$1(index, bufferMap));
	                            }));
	              }), unsafeGet$1(index, bufferMap));
	}

	function addGeometryBufferToPool$1(geometryIndex, state) {
	  var match = getVboBufferData(state);
	  var vertexBufferMap = match[/* vertexBufferMap */0];
	  var elementArrayBufferMap = match[/* elementArrayBufferMap */1];
	  match[/* vertexArrayBufferPool */3].push(_unsafeGetBufferFromBufferMap(geometryIndex, vertexBufferMap));
	  match[/* elementArrayBufferPool */4].push(_unsafeGetBufferFromBufferMap(geometryIndex, elementArrayBufferMap));
	  return state;
	}

	function addAllBufferToPool(state) {
	  var match = getVboBufferData(state);
	  var vertexBufferMap = match[/* vertexBufferMap */0];
	  var elementArrayBufferMap = match[/* elementArrayBufferMap */1];
	  var modelMatrixInstanceBufferMap = match[/* modelMatrixInstanceBufferMap */2];
	  var modelMatrixInstanceBufferPool = match[/* modelMatrixInstanceBufferPool */5];
	  var elementArrayBufferPool = match[/* elementArrayBufferPool */4];
	  var vertexArrayBufferPool = match[/* vertexArrayBufferPool */3];
	  forEachValid((function (buffer) {
	          vertexArrayBufferPool.push(buffer);
	          return /* () */0;
	        }), vertexBufferMap);
	  forEachValid((function (buffer) {
	          elementArrayBufferPool.push(buffer);
	          return /* () */0;
	        }), elementArrayBufferMap);
	  forEachValid((function (buffer) {
	          modelMatrixInstanceBufferPool.push(buffer);
	          return /* () */0;
	        }), modelMatrixInstanceBufferMap);
	  return /* tuple */[
	          vertexArrayBufferPool,
	          elementArrayBufferPool,
	          modelMatrixInstanceBufferPool
	        ];
	}

	function addInstanceBufferToPool$1(sourceInstanceIndex, state) {
	  var match = getVboBufferData(state);
	  var modelMatrixInstanceBufferMap = match[/* modelMatrixInstanceBufferMap */2];
	  match[/* modelMatrixInstanceBufferPool */5].push(_unsafeGetBufferFromBufferMap(sourceInstanceIndex, modelMatrixInstanceBufferMap));
	  return state;
	}


	/* SparseMapSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function deepCopyStateForRestore$16(state) {
	  var newrecord = state.slice();
	  newrecord[/* vboBufferData */24] = /* record */[
	    /* vertexBufferMap : array */[],
	    /* elementArrayBufferMap : array */[],
	    /* modelMatrixInstanceBufferMap : array */[],
	    /* vertexArrayBufferPool : array */[],
	    /* elementArrayBufferPool : array */[],
	    /* modelMatrixInstanceBufferPool : array */[]
	  ];
	  return newrecord;
	}

	function restore$16(currentState, targetState) {
	  var match = addAllBufferToPool(currentState);
	  var newrecord = targetState.slice();
	  newrecord[/* vboBufferData */24] = /* record */[
	    /* vertexBufferMap : array */[],
	    /* elementArrayBufferMap : array */[],
	    /* modelMatrixInstanceBufferMap : array */[],
	    /* vertexArrayBufferPool */match[0],
	    /* elementArrayBufferPool */match[1],
	    /* modelMatrixInstanceBufferPool */match[2]
	  ];
	  return newrecord;
	}


	/* VboBufferPoolCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getOrCreateBuffer(gl, geometryIndex, bufferMap, createBuffer, getDataFunc, state) {
	  var match = get$3(geometryIndex, bufferMap);
	  if (match) {
	    return match[0];
	  } else {
	    var buffer = createBuffer(gl, getDataFunc(geometryIndex, state), state);
	    set$1(geometryIndex, buffer, bufferMap);
	    return buffer;
	  }
	}

	var addGeometryBufferToPool = addGeometryBufferToPool$1;

	var addInstanceBufferToPool = addInstanceBufferToPool$1;

	var deepCopyStateForRestore$15 = deepCopyStateForRestore$16;

	var restore$15 = restore$16;


	/* VboBufferPoolCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var disposeSparseMapData$1 = disposeSparseMapData;


	/* ComponentDisposeComponentCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function disposeGeometryBufferData(geometry, state) {
	  var match = getVboBufferData(state);
	  var vertexBufferMap = match[/* vertexBufferMap */0];
	  var elementArrayBufferMap = match[/* elementArrayBufferMap */1];
	  disposeSparseMapData$1(geometry, vertexBufferMap);
	  disposeSparseMapData$1(geometry, elementArrayBufferMap);
	  return state;
	}

	function disposeInstanceBufferData(sourceInstance, state) {
	  var match = getVboBufferData(state);
	  var modelMatrixInstanceBufferMap = match[/* modelMatrixInstanceBufferMap */2];
	  disposeSparseMapData$1(sourceInstance, modelMatrixInstanceBufferMap);
	  return state;
	}


	/* ComponentAdmin-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function addTypeArrayToPool$1(geometry, maxSize, verticesMap, indicesMap, state) {
	  addFloat32TypeArrayToPool(unsafeGet$1(geometry, verticesMap), maxSize, getFloat32ArrayPoolMap(state));
	  addUint16TypeArrayToPool(unsafeGet$1(geometry, indicesMap), maxSize, getUint16ArrayPoolMap(state));
	  return state;
	}

	function addAllTypeArrayToPool$1(maxSize, verticesMap, indicesMap, float32ArrayPoolMap, uint16ArrayPoolMap) {
	  return /* tuple */[
	          addAllFloat32TypeArrayToPool(verticesMap, maxSize, float32ArrayPoolMap),
	          addAllUint16TypeArrayToPool(indicesMap, maxSize, uint16ArrayPoolMap)
	        ];
	}


	/* TypeArrayPoolSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isAlive$5(geometry, state) {
	  return isAlive$3(geometry, getGeometryData(state)[/* disposedIndexArray */6]);
	}

	function _disposeData$1(geometry, state) {
	  var match = getGeometryData(state);
	  var indicesMap = match[/* indicesMap */2];
	  var verticesMap = match[/* verticesMap */1];
	  var computeDataFuncMap = match[/* computeDataFuncMap */3];
	  var configDataMap = match[/* configDataMap */4];
	  var gameObjectMap = match[/* gameObjectMap */5];
	  var isInitMap = match[/* isInitMap */7];
	  var groupCountMap = match[/* groupCountMap */8];
	  var state$1 = addTypeArrayToPool$1(geometry, getMaxTypeArrayPoolSize(state), verticesMap, indicesMap, disposeGeometryBufferData(geometry, state));
	  set$1(geometry, 0, groupCountMap);
	  disposeSparseMapData(geometry, verticesMap);
	  disposeSparseMapData(geometry, indicesMap);
	  disposeSparseMapData(geometry, configDataMap);
	  disposeSparseMapData(geometry, isInitMap);
	  disposeSparseMapData(geometry, computeDataFuncMap);
	  disposeSparseMapData(geometry, groupCountMap);
	  disposeSparseMapData(geometry, gameObjectMap);
	  return state$1;
	}

	function handleDisposeComponent$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$5, state);
	        }));
	  var match = getGeometryData(state);
	  var disposedIndexArray = match[/* disposedIndexArray */6];
	  var match$1 = isGroupGeometry(geometry, state);
	  if (match$1 !== 0) {
	    return decreaseGroupCount(geometry, state);
	  } else {
	    var state$1 = _disposeData$1(geometry, addGeometryBufferToPool(geometry, state));
	    disposedIndexArray.push(geometry);
	    return state$1;
	  }
	}

	function handleBatchDisposeComponent$1(geometryArray, _, state) {
	  requireCheck((function () {
	          return forEach((function (geometry) {
	                        return checkComponentShouldAlive$1(geometry, isAlive$5, state);
	                      }), geometryArray);
	        }));
	  var data = getGeometryData(state);
	  var disposedIndexArray = data[/* disposedIndexArray */6];
	  return reduceState((function (state, geometry) {
	                var match = isGroupGeometry(geometry, state);
	                if (match !== 0) {
	                  return decreaseGroupCount(geometry, state);
	                } else {
	                  disposedIndexArray.push(geometry);
	                  return _disposeData$1(geometry, addGeometryBufferToPool(geometry, state));
	                }
	              }), state, geometryArray);
	}

	function isNotDisposed(param) {
	  var disposedIndexArray = param[/* disposedIndexArray */6];
	  return +(disposedIndexArray.length === 0);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isAlive$6(material, state) {
	  return isAlive$3(material, getMaterialData(state)[/* disposedIndexArray */5]);
	}

	function _disposeData$2(material, state) {
	  var data = getMaterialData(state);
	  set$1(material, 0, data[/* groupCountMap */4]);
	  disposeSparseMapData(material, data[/* colorMap */2]);
	  disposeSparseMapData(material, data[/* shaderIndexMap */1]);
	  disposeSparseMapData(material, data[/* gameObjectMap */3]);
	  return state;
	}

	function handleDisposeComponent$2(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$6, state);
	        }));
	  var match = getMaterialData(state);
	  var disposedIndexArray = match[/* disposedIndexArray */5];
	  var match$1 = isGroupMaterial(material, state);
	  if (match$1 !== 0) {
	    return decreaseGroupCount$2(material, state);
	  } else {
	    disposedIndexArray.push(material);
	    return _disposeData$2(material, state);
	  }
	}

	function handleBatchDisposeComponent$2(materialArray, _, state) {
	  requireCheck((function () {
	          return forEach((function (material) {
	                        return checkComponentShouldAlive$1(material, isAlive$6, state);
	                      }), materialArray);
	        }));
	  var data = getMaterialData(state);
	  var disposedIndexArray = data[/* disposedIndexArray */5];
	  return reduceState((function (state, material) {
	                var match = isGroupMaterial(material, state);
	                if (match !== 0) {
	                  return decreaseGroupCount$2(material, state);
	                } else {
	                  disposedIndexArray.push(material);
	                  return _disposeData$2(material, state);
	                }
	              }), state, materialArray);
	}

	function isNotDisposed$1(param) {
	  var disposedIndexArray = param[/* disposedIndexArray */5];
	  return +(disposedIndexArray.length === 0);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getMeshRendererData(state) {
	  return state[/* meshRendererData */15];
	}

	function deepCopyStateForRestore$17(state) {
	  var match = state[/* meshRendererData */15];
	  var index = match[/* index */0];
	  var renderGameObjectArray = match[/* renderGameObjectArray */1];
	  var disposedIndexArray = match[/* disposedIndexArray */3];
	  var newrecord = state.slice();
	  newrecord[/* meshRendererData */15] = /* record */[
	    /* index */index,
	    /* renderGameObjectArray */renderGameObjectArray.slice(),
	    /* gameObjectMap */copy$1(match[/* gameObjectMap */2]),
	    /* disposedIndexArray */disposedIndexArray.slice()
	  ];
	  return newrecord;
	}


	/* SparseMapSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleAddComponent$4(meshRenderer, gameObjectUid, state) {
	  var match = getMeshRendererData(state);
	  var renderGameObjectArray = match[/* renderGameObjectArray */1];
	  renderGameObjectArray.push(gameObjectUid);
	  addComponentToGameObjectMap(meshRenderer, gameObjectUid, match[/* gameObjectMap */2]);
	  return state;
	}


	/* MeshRendererStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function create$6(state) {
	  var data = getMeshRendererData(state);
	  var index = data[/* index */0];
	  var disposedIndexArray = data[/* disposedIndexArray */3];
	  var match = generateIndex(index, disposedIndexArray);
	  data[/* index */0] = match[1];
	  return /* tuple */[
	          state,
	          match[0]
	        ];
	}


	/* MeshRendererStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleCloneComponent$3(countRangeArr, state) {
	  var componentArr = /* array */[];
	  var state$1 = reduceState((function (state, _) {
	          var match = create$6(state);
	          componentArr.push(match[1]);
	          return match[0];
	        }), state, countRangeArr);
	  return /* tuple */[
	          state$1,
	          componentArr
	        ];
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleAddComponent$5(_, _$1, state) {
	  return state;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getSourceInstanceData(state) {
	  return state[/* sourceInstanceData */5];
	}

	function deepCopyStateForRestore$18(state) {
	  var match = state[/* sourceInstanceData */5];
	  var index = match[/* index */0];
	  var objectInstanceArrayMap = match[/* objectInstanceArrayMap */1];
	  var disposedIndexArray = match[/* disposedIndexArray */6];
	  var newrecord = state.slice();
	  newrecord[/* sourceInstanceData */5] = /* record */[
	    /* index */index,
	    /* objectInstanceArrayMap */deepCopyArrayArray(objectInstanceArrayMap),
	    /* modelMatrixInstanceBufferCapacityMap */copy$1(match[/* modelMatrixInstanceBufferCapacityMap */2]),
	    /* modelMatrixFloat32ArrayMap */deepCopyFloat32ArrayArray(match[/* modelMatrixFloat32ArrayMap */3]),
	    /* isModelMatrixStaticMap */copy$1(match[/* isModelMatrixStaticMap */4]),
	    /* isSendModelMatrixDataMap */match[/* isSendModelMatrixDataMap */5],
	    /* disposedIndexArray */disposedIndexArray.slice(),
	    /* gameObjectMap */copy$1(match[/* gameObjectMap */7])
	  ];
	  return newrecord;
	}

	function _buildIsNotSendModelMatrixDataMap(isSendModelMatrixDataMap) {
	  return reduceiValid((function (newMap, _, index) {
	                return set$1(index, /* false */0, newMap);
	              }), createEmpty$2(/* () */0), isSendModelMatrixDataMap);
	}

	function restore$17(currentState, sharedData, targetState) {
	  var match = currentState[/* sourceInstanceData */5];
	  var targetData = targetState[/* sourceInstanceData */5];
	  var float32ArrayPoolMap = addAllFloat32TypeArrayToPool(match[/* modelMatrixFloat32ArrayMap */3], getMaxBigTypeArrayPoolSize(targetState), sharedData[/* float32ArrayPoolMap */1]);
	  var newrecord = targetState.slice();
	  var newrecord$1 = targetData.slice();
	  newrecord$1[/* isSendModelMatrixDataMap */5] = _buildIsNotSendModelMatrixDataMap(targetData[/* isSendModelMatrixDataMap */5]);
	  newrecord[/* sourceInstanceData */5] = newrecord$1;
	  return /* tuple */[
	          newrecord,
	          /* record */[
	            /* gl */sharedData[/* gl */0],
	            /* float32ArrayPoolMap */float32ArrayPoolMap,
	            /* uint16ArrayPoolMap */sharedData[/* uint16ArrayPoolMap */2]
	          ]
	        ];
	}


	/* CopyStateUtils-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleAddComponent$6(sourceInstance, gameObjectUid, state) {
	  var data = getSourceInstanceData(state);
	  addComponentToGameObjectMap(sourceInstance, gameObjectUid, data[/* gameObjectMap */7]);
	  return state;
	}


	/* SourceInstanceStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getCameraControllerData(state) {
	  return state[/* cameraControllerData */12];
	}

	function getPerspectiveCameraDataFromCameraControllerData(cameraControllerData) {
	  return cameraControllerData[/* perspectiveCameraData */6];
	}

	function getPerspectiveCameraData(state) {
	  return state[/* cameraControllerData */12][/* perspectiveCameraData */6];
	}

	function _deepCopyPerspectiveCameraState(perspectiveCameraData) {
	  return /* record */[
	          /* nearMap */perspectiveCameraData[/* nearMap */0].slice(),
	          /* farMap */perspectiveCameraData[/* farMap */1].slice(),
	          /* fovyMap */perspectiveCameraData[/* fovyMap */2].slice(),
	          /* aspectMap */perspectiveCameraData[/* aspectMap */3].slice()
	        ];
	}

	function deepCopyStateForRestore$19(state) {
	  var match = state[/* cameraControllerData */12];
	  var index = match[/* index */0];
	  var cameraArray = match[/* cameraArray */1];
	  var dirtyArray = match[/* dirtyArray */2];
	  var pMatrixMap = match[/* pMatrixMap */3];
	  var gameObjectMap = match[/* gameObjectMap */4];
	  var updateCameraFuncMap = match[/* updateCameraFuncMap */5];
	  var perspectiveCameraData = match[/* perspectiveCameraData */6];
	  var disposedIndexArray = match[/* disposedIndexArray */7];
	  var newrecord = state.slice();
	  newrecord[/* cameraControllerData */12] = /* record */[
	    /* index */index,
	    /* cameraArray */cameraArray.slice(),
	    /* dirtyArray */dirtyArray.slice(),
	    /* pMatrixMap */deepCopyFloat32ArrayArray(pMatrixMap),
	    /* gameObjectMap */copy$1(gameObjectMap),
	    /* updateCameraFuncMap */updateCameraFuncMap.slice(),
	    /* perspectiveCameraData */_deepCopyPerspectiveCameraState(perspectiveCameraData),
	    /* disposedIndexArray */disposedIndexArray.slice()
	  ];
	  return newrecord;
	}


	/* CopyStateUtils-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleAddComponent$7(cameraController, gameObjectUid, state) {
	  var cameraControllerData = getCameraControllerData(state);
	  addComponentToGameObjectMap(cameraController, gameObjectUid, cameraControllerData[/* gameObjectMap */4]);
	  return state;
	}


	/* CameraControllerStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _removeFromRenderArray(disposedGameObjectUid, data) {
	  var renderGameObjectArray = data[/* renderGameObjectArray */1];
	  removeFromArray(disposedGameObjectUid, renderGameObjectArray);
	  return data;
	}

	function _batchRemoveFromRenderArray(disposedGameObjectUidMap, data) {
	  var renderGameObjectArray = data[/* renderGameObjectArray */1];
	  data[/* renderGameObjectArray */1] = batchRemoveFromArray(disposedGameObjectUidMap, renderGameObjectArray);
	  return data;
	}

	function isAlive$7(meshRenderer, state) {
	  return isAlive$3(meshRenderer, getMeshRendererData(state)[/* disposedIndexArray */3]);
	}

	function _disposeData$3(meshRenderer, state) {
	  var data = getMeshRendererData(state);
	  disposeSparseMapData(meshRenderer, data[/* gameObjectMap */2]);
	  return state;
	}

	function handleDisposeComponent$3(meshRenderer, gameObjectUid, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(meshRenderer, isAlive$7, state);
	        }));
	  var data = getMeshRendererData(state);
	  var disposedIndexArray = data[/* disposedIndexArray */3];
	  disposedIndexArray.push(meshRenderer);
	  _removeFromRenderArray(gameObjectUid, data);
	  return _disposeData$3(meshRenderer, state);
	}

	function handleBatchDisposeComponent$3(meshRendererArray, gameObjectUidMap, state) {
	  requireCheck((function () {
	          return forEach((function (meshRenderer) {
	                        return checkComponentShouldAlive$1(meshRenderer, isAlive$7, state);
	                      }), meshRendererArray);
	        }));
	  var data = getMeshRendererData(state);
	  var disposedIndexArray = data[/* disposedIndexArray */3];
	  data[/* disposedIndexArray */3] = disposedIndexArray.concat(meshRendererArray);
	  _batchRemoveFromRenderArray(gameObjectUidMap, data);
	  return reduceState((function (state, meshRenderer) {
	                return _disposeData$3(meshRenderer, state);
	              }), state, meshRendererArray);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function addToDirtyArray(cameraController, param) {
	  var dirtyArray = param[/* dirtyArray */2];
	  return dirtyArray.push(cameraController);
	}

	function cleanDirtyArray(cameraControllerData) {
	  cameraControllerData[/* dirtyArray */2] = createEmpty(/* () */0);
	  return cameraControllerData;
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getFovy$1(cameraController, cameraData) {
	  return get$3(cameraController, cameraData[/* fovyMap */2]);
	}

	function setFovy$1(cameraController, fovy, state) {
	  set$1(cameraController, fovy, getPerspectiveCameraData(state)[/* fovyMap */2]);
	  addToDirtyArray(cameraController, getCameraControllerData(state));
	  return state;
	}

	function getAspect$1(cameraController, cameraData) {
	  return get$3(cameraController, cameraData[/* aspectMap */3]);
	}

	function setAspect$1(cameraController, aspect, state) {
	  set$1(cameraController, aspect, getPerspectiveCameraData(state)[/* aspectMap */3]);
	  addToDirtyArray(cameraController, getCameraControllerData(state));
	  return state;
	}

	function getNear$1(cameraController, cameraData) {
	  return get$3(cameraController, cameraData[/* nearMap */0]);
	}

	function setNear$1(cameraController, near, state) {
	  set$1(cameraController, near, getPerspectiveCameraData(state)[/* nearMap */0]);
	  addToDirtyArray(cameraController, getCameraControllerData(state));
	  return state;
	}

	function getFar$1(cameraController, cameraData) {
	  return get$3(cameraController, cameraData[/* farMap */1]);
	}

	function setFar$1(cameraController, far, state) {
	  set$1(cameraController, far, getPerspectiveCameraData(state)[/* farMap */1]);
	  addToDirtyArray(cameraController, getCameraControllerData(state));
	  return state;
	}


	/* CameraControllerDirtyCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function setDefaultPMatrix(cameraController, cameraControllerData) {
	  set$1(cameraController, createIdentityMatrix4(/* () */0), cameraControllerData[/* pMatrixMap */3]);
	  return cameraControllerData;
	}

	function _unsafeGetPMatrix(cameraController, cameraControllerData) {
	  return ensureCheck((function () {
	                return test("pMatrix should exist", (function () {
	                              return assertExist(get$3(cameraController, cameraControllerData[/* pMatrixMap */3]));
	                            }));
	              }), unsafeGet$1(cameraController, cameraControllerData[/* pMatrixMap */3]));
	}

	function update$2(index, cameraControllerData) {
	  var cameraData = getPerspectiveCameraDataFromCameraControllerData(cameraControllerData);
	  var match = getFovy$1(index, cameraData);
	  var match$1 = getAspect$1(index, cameraData);
	  var match$2 = getNear$1(index, cameraData);
	  var match$3 = getFar$1(index, cameraData);
	  if (match && match$1 && match$2 && match$3) {
	    buildPerspective(match[0], match$1[0], match$2[0], match$3[0], _unsafeGetPMatrix(index, cameraControllerData));
	  } else {
	    throwMessage("fovy,aspect,near,far should all exist");
	  }
	  return /* () */0;
	}

	var init$2 = update$2;

	var getFovy = getFovy$1;

	var setFovy = setFovy$1;

	var getAspect = getAspect$1;

	var setAspect = setAspect$1;

	var getFar = getFar$1;

	var setFar = setFar$1;

	var getNear = getNear$1;

	var setNear = setNear$1;


	/* CameraControllerStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function create$7(state) {
	  var data = getCameraControllerData(state);
	  var index = data[/* index */0];
	  var cameraArray = data[/* cameraArray */1];
	  var disposedIndexArray = data[/* disposedIndexArray */7];
	  var match = generateIndex(index, disposedIndexArray);
	  var index$1 = match[0];
	  data[/* index */0] = match[1];
	  cameraArray.push(index$1);
	  addToDirtyArray(index$1, data);
	  setDefaultPMatrix(index$1, data);
	  return /* tuple */[
	          state,
	          index$1
	        ];
	}


	/* PerspectiveCameraSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function handleCloneComponent$4(sourceComponent, countRangeArr, state) {
	  var cameraData = getPerspectiveCameraData(state);
	  var near = getExn(getNear$1(sourceComponent, cameraData));
	  var far = getExn(getFar$1(sourceComponent, cameraData));
	  var fovy = getExn(getFovy$1(sourceComponent, cameraData));
	  var aspect = getExn(getAspect$1(sourceComponent, cameraData));
	  var componentArr = /* array */[];
	  var state$1 = reduceState((function (state, _) {
	          var match = create$7(state);
	          var index = match[1];
	          var state$1 = setAspect$1(index, aspect, setFovy$1(index, fovy, setFar$1(index, far, setNear$1(index, near, match[0]))));
	          componentArr.push(index);
	          return state$1;
	        }), state, countRangeArr);
	  return /* tuple */[
	          state$1,
	          componentArr
	        ];
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function buildMapFromArray(array, map) {
	  forEach((function (value) {
	          set$1(value, /* true */1, map);
	          return /* () */0;
	        }), array);
	  return map;
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getObjectInstanceData(state) {
	  return state[/* objectInstanceData */6];
	}

	function deepCopyStateForRestore$20(state) {
	  var match = state[/* objectInstanceData */6];
	  var index = match[/* index */0];
	  var disposedIndexArray = match[/* disposedIndexArray */2];
	  var newrecord = state.slice();
	  newrecord[/* objectInstanceData */6] = /* record */[
	    /* index */index,
	    /* sourceInstanceMap */copy$1(match[/* sourceInstanceMap */1]),
	    /* disposedIndexArray */disposedIndexArray.slice(),
	    /* gameObjectMap */copy$1(match[/* gameObjectMap */3])
	  ];
	  return newrecord;
	}


	/* SparseMapSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function unsafeGetObjectInstanceArray(sourceInstance, objectInstanceArrayMap) {
	  return ensureCheck((function () {
	                return test("objectInstanceArray of sourceInstance:" + (String(sourceInstance) + " should exist"), (function () {
	                              return assertExist(get$3(sourceInstance, objectInstanceArrayMap));
	                            }));
	              }), unsafeGet$1(sourceInstance, objectInstanceArrayMap));
	}

	function getObjectInstanceArray(sourceInstance, state) {
	  return unsafeGetObjectInstanceArray(sourceInstance, getSourceInstanceData(state)[/* objectInstanceArrayMap */1]);
	}


	/* SourceInstanceStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function disposeObjectInstance(sourceInstance, objectInstanceUid, state) {
	  var match = getSourceInstanceData(state);
	  var objectInstanceArrayMap = match[/* objectInstanceArrayMap */1];
	  removeFromArray(objectInstanceUid, unsafeGetObjectInstanceArray(sourceInstance, objectInstanceArrayMap));
	  return state;
	}

	function batchDisposeObjectInstance(sourceInstance, disposedUidMap, disposedUidArr, state) {
	  var match = getSourceInstanceData(state);
	  var objectInstanceArrayMap = match[/* objectInstanceArrayMap */1];
	  set$1(sourceInstance, batchRemoveFromArray(disposedUidMap, disposedUidArr), objectInstanceArrayMap);
	  return state;
	}


	/* SourceInstanceStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function unsafeGetGameObject$1(objectInstance, state) {
	  return unsafeGetComponentGameObject(objectInstance, getObjectInstanceData(state)[/* gameObjectMap */3]);
	}


	/* ObjectInstanceStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isAlive$8(objectInstance, state) {
	  return isAlive$3(objectInstance, getObjectInstanceData(state)[/* disposedIndexArray */2]);
	}

	function _getSourceInstance(objectInstance, param) {
	  var sourceInstanceMap = param[/* sourceInstanceMap */1];
	  return ensureCheck((function () {
	                return test("sourceInstance should exist", (function () {
	                              return assertExist(get$3(objectInstance, sourceInstanceMap));
	                            }));
	              }), unsafeGet$1(objectInstance, sourceInstanceMap));
	}

	function _disposeData$4(objectInstance, state) {
	  var match = getObjectInstanceData(state);
	  disposeSparseMapData(objectInstance, match[/* sourceInstanceMap */1]);
	  disposeSparseMapData(objectInstance, match[/* gameObjectMap */3]);
	  return state;
	}

	function handleDisposeComponent$4(objectInstance, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(objectInstance, isAlive$8, state);
	        }));
	  var data = getObjectInstanceData(state);
	  var disposedIndexArray = data[/* disposedIndexArray */2];
	  disposedIndexArray.push(objectInstance);
	  return _disposeData$4(objectInstance, disposeObjectInstance(_getSourceInstance(objectInstance, data), unsafeGetGameObject$1(objectInstance, state), state));
	}

	function handleBatchDisposeComponent$4(objectInstanceArray, _, state) {
	  requireCheck((function () {
	          forEach((function (objectInstance) {
	                  return checkComponentShouldAlive$1(objectInstance, isAlive$8, state);
	                }), objectInstanceArray);
	          test("objectInstanceArray should has one objectInstance at least", (function () {
	                  return Operators[/* > */5](objectInstanceArray.length, 0);
	                }));
	          return test("all objectInstance should belong to the same sourceInstance", (function () {
	                        var data = getObjectInstanceData(state);
	                        var sourceInstance = _getSourceInstance(caml_array_get(objectInstanceArray, 0), data);
	                        return forEach((function (objectInstance) {
	                                      return Operators[/* = */0](_getSourceInstance(objectInstance, data), sourceInstance);
	                                    }), objectInstanceArray);
	                      }));
	        }));
	  var data = getObjectInstanceData(state);
	  var disposedIndexArray = data[/* disposedIndexArray */2];
	  data[/* disposedIndexArray */2] = disposedIndexArray.concat(objectInstanceArray);
	  var disposedUidArr = objectInstanceArray.map((function (objectInstance) {
	          return unsafeGetGameObject$1(objectInstance, state);
	        }));
	  var disposedUidMap = buildMapFromArray(disposedUidArr, createEmpty$2(/* () */0));
	  var sourceInstance = _getSourceInstance(caml_array_get(objectInstanceArray, 0), data);
	  var state$1 = batchDisposeObjectInstance(sourceInstance, disposedUidMap, disposedUidArr, state);
	  return reduceState((function (state, objectInstance) {
	                return _disposeData$4(objectInstance, state);
	              }), state$1, objectInstanceArray);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isAlive$9(sourceInstance, state) {
	  return isAlive$3(sourceInstance, getSourceInstanceData(state)[/* disposedIndexArray */6]);
	}

	function _disposeObjectInstanceGameObject(sourceInstance, batchDisposeGameObjectFunc, state) {
	  var objectInstanceGameObjectArr = unsafeGetObjectInstanceArray(sourceInstance, getSourceInstanceData(state)[/* objectInstanceArrayMap */1]).slice();
	  return _2(batchDisposeGameObjectFunc, objectInstanceGameObjectArr, state);
	}

	function _disposeData$5(sourceInstance, batchDisposeGameObjectFunc, state) {
	  var state$1 = _disposeObjectInstanceGameObject(sourceInstance, batchDisposeGameObjectFunc, disposeInstanceBufferData(sourceInstance, state));
	  var match = getSourceInstanceData(state$1);
	  var objectInstanceArrayMap = match[/* objectInstanceArrayMap */1];
	  var modelMatrixFloat32ArrayMap = match[/* modelMatrixFloat32ArrayMap */3];
	  var match$1 = get$3(sourceInstance, modelMatrixFloat32ArrayMap);
	  if (match$1) {
	    addFloat32TypeArrayToPool(match$1[0], getMaxBigTypeArrayPoolSize(state$1), getFloat32ArrayPoolMap(state$1));
	  }
	  disposeSparseMapData(sourceInstance, objectInstanceArrayMap);
	  disposeSparseMapData(sourceInstance, modelMatrixFloat32ArrayMap);
	  disposeSparseMapData(sourceInstance, match[/* modelMatrixInstanceBufferCapacityMap */2]);
	  disposeSparseMapData(sourceInstance, match[/* isModelMatrixStaticMap */4]);
	  disposeSparseMapData(sourceInstance, match[/* isSendModelMatrixDataMap */5]);
	  disposeSparseMapData(sourceInstance, match[/* gameObjectMap */7]);
	  return state$1;
	}

	function handleDisposeComponent$5(sourceInstance, batchDisposeGameObjectFunc, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(sourceInstance, isAlive$9, state);
	        }));
	  var data = getSourceInstanceData(state);
	  var disposedIndexArray = data[/* disposedIndexArray */6];
	  disposedIndexArray.push(sourceInstance);
	  return _disposeData$5(sourceInstance, batchDisposeGameObjectFunc, addInstanceBufferToPool(sourceInstance, state));
	}

	function handleBatchDisposeComponent$5(sourceInstanceArray, _, batchDisposeGameObjectFunc, state) {
	  requireCheck((function () {
	          return forEach((function (sourceInstance) {
	                        return checkComponentShouldAlive$1(sourceInstance, isAlive$9, state);
	                      }), sourceInstanceArray);
	        }));
	  var data = getSourceInstanceData(state);
	  var disposedIndexArray = data[/* disposedIndexArray */6];
	  data[/* disposedIndexArray */6] = disposedIndexArray.concat(sourceInstanceArray);
	  return reduceState((function (state, sourceInstance) {
	                return _disposeData$5(sourceInstance, batchDisposeGameObjectFunc, addInstanceBufferToPool(sourceInstance, state));
	              }), state, sourceInstanceArray);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function disposeData(cameraController, state) {
	  var data = getPerspectiveCameraData(state);
	  disposeSparseMapData(cameraController, data[/* nearMap */0]);
	  disposeSparseMapData(cameraController, data[/* farMap */1]);
	  disposeSparseMapData(cameraController, data[/* fovyMap */2]);
	  disposeSparseMapData(cameraController, data[/* aspectMap */3]);
	  return state;
	}


	/* CameraControllerStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isAlive$10(cameraController, state) {
	  return isAlive$3(cameraController, getCameraControllerData(state)[/* disposedIndexArray */7]);
	}

	function _disposeData$6(cameraController, state) {
	  var state$1 = disposeData(cameraController, state);
	  var data = getCameraControllerData(state$1);
	  var cameraArray = data[/* cameraArray */1];
	  var dirtyArray = data[/* dirtyArray */2];
	  var pMatrixMap = data[/* pMatrixMap */3];
	  var gameObjectMap = data[/* gameObjectMap */4];
	  var updateCameraFuncMap = data[/* updateCameraFuncMap */5];
	  disposeSparseMapData(cameraController, cameraArray);
	  disposeSparseMapData(cameraController, dirtyArray);
	  disposeSparseMapData(cameraController, pMatrixMap);
	  disposeSparseMapData(cameraController, gameObjectMap);
	  disposeSparseMapData(cameraController, updateCameraFuncMap);
	  return state$1;
	}

	function handleDisposeComponent$6(cameraController, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(cameraController, isAlive$10, state);
	        }));
	  var match = getCameraControllerData(state);
	  var disposedIndexArray = match[/* disposedIndexArray */7];
	  disposedIndexArray.push(cameraController);
	  return _disposeData$6(cameraController, state);
	}

	function handleBatchDisposeComponent$6(cameraControllerArray, _, state) {
	  requireCheck((function () {
	          return forEach((function (cameraController) {
	                        return checkComponentShouldAlive$1(cameraController, isAlive$10, state);
	                      }), cameraControllerArray);
	        }));
	  var data = getCameraControllerData(state);
	  var disposedIndexArray = data[/* disposedIndexArray */7];
	  data[/* disposedIndexArray */7] = disposedIndexArray.concat(cameraControllerArray);
	  return reduceState((function (state, cameraController) {
	                return _disposeData$6(cameraController, state);
	              }), state, cameraControllerArray);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _unsafeGetComponent(uid, componentMap) {
	  return ensureCheck((function () {
	                return test("component should exist", (function () {
	                              return assertExist(get$3(uid, componentMap));
	                            }));
	              }), unsafeGet$1(uid, componentMap));
	}

	function _addComponent(uid, component, componentMap) {
	  requireCheck((function () {
	          return test("this type of component is already exist, shouldn't add again", (function () {
	                        return assertFalse(isSome(get$3(uid, componentMap)));
	                      }));
	        }));
	  set$1(uid, component, componentMap);
	  return /* () */0;
	}

	function hasSourceInstanceComponent$2(uid, state) {
	  var componentMap = getGameObjectData(state)[/* sourceInstanceMap */9];
	  return isSome(get$3(uid, componentMap));
	}

	function getSourceInstanceComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* sourceInstanceMap */9];
	  return get$3(uid, componentMap);
	}

	function unsafeGetSourceInstanceComponent(uid, state) {
	  return _unsafeGetComponent(uid, getGameObjectData(state)[/* sourceInstanceMap */9]);
	}

	function addSourceInstanceComponent$1(uid, component, state) {
	  _addComponent(uid, component, getGameObjectData(state)[/* sourceInstanceMap */9]);
	  return handleAddComponent$6(component, uid, state);
	}

	function disposeSourceInstanceComponent$1(_, component, batchDisposeGameObjectFunc, state) {
	  return handleDisposeComponent$5(component, batchDisposeGameObjectFunc, state);
	}

	function hasObjectInstanceComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* objectInstanceMap */10];
	  return isSome(get$3(uid, componentMap));
	}

	function getObjectInstanceComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* objectInstanceMap */10];
	  return get$3(uid, componentMap);
	}

	function addObjectInstanceComponent$1(uid, component, state) {
	  _addComponent(uid, component, getGameObjectData(state)[/* objectInstanceMap */10]);
	  return handleAddComponent$5(component, uid, state);
	}

	function disposeObjectInstanceComponent$1(_, component, state) {
	  return handleDisposeComponent$4(component, state);
	}

	function hasCameraControllerComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* cameraControllerMap */5];
	  return isSome(get$3(uid, componentMap));
	}

	function getCameraControllerComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* cameraControllerMap */5];
	  return get$3(uid, componentMap);
	}

	function addCameraControllerComponent$1(uid, component, state) {
	  _addComponent(uid, component, getGameObjectData(state)[/* cameraControllerMap */5]);
	  return handleAddComponent$7(component, uid, state);
	}

	function disposeCameraControllerComponent$1(_, component, state) {
	  return handleDisposeComponent$6(component, state);
	}

	function hasTransformComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* transformMap */4];
	  return isSome(get$3(uid, componentMap));
	}

	function getTransformComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* transformMap */4];
	  return get$3(uid, componentMap);
	}

	function unsafeGetTransformComponent$1(uid, state) {
	  return _unsafeGetComponent(uid, getGameObjectData(state)[/* transformMap */4]);
	}

	function addTransformComponent$1(uid, component, state) {
	  _addComponent(uid, component, getGameObjectData(state)[/* transformMap */4]);
	  return handleAddComponent$1(component, uid, state);
	}

	function disposeTransformComponent$1(_, component, state) {
	  return handleDisposeComponent(component, state);
	}

	function hasGeometryComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* geometryMap */6];
	  return isSome(get$3(uid, componentMap));
	}

	function getGeometryComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* geometryMap */6];
	  return get$3(uid, componentMap);
	}

	function unsafeGetGeometryComponent$1(uid, state) {
	  return _unsafeGetComponent(uid, getGameObjectData(state)[/* geometryMap */6]);
	}

	function addGeometryComponent$1(uid, component, state) {
	  _addComponent(uid, component, getGameObjectData(state)[/* geometryMap */6]);
	  var match = getGameObject$4(component, state);
	  if (match) {
	    return increaseGroupCount(component, state);
	  } else {
	    return handleAddComponent$2(component, uid, state);
	  }
	}

	function disposeGeometryComponent$1(_, component, state) {
	  return handleDisposeComponent$1(component, state);
	}

	function hasMeshRendererComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* meshRendererMap */7];
	  return isSome(get$3(uid, componentMap));
	}

	function getMeshRendererComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* meshRendererMap */7];
	  return get$3(uid, componentMap);
	}

	function addMeshRendererComponent$1(uid, component, state) {
	  _addComponent(uid, component, getGameObjectData(state)[/* meshRendererMap */7]);
	  return handleAddComponent$4(component, uid, state);
	}

	function disposeMeshRendererComponent$1(uid, component, state) {
	  return handleDisposeComponent$3(component, uid, state);
	}

	function hasMaterialComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* materialMap */8];
	  return isSome(get$3(uid, componentMap));
	}

	function getMaterialComponent$1(uid, state) {
	  var componentMap = getGameObjectData(state)[/* materialMap */8];
	  return get$3(uid, componentMap);
	}

	function unsafeGetMaterialComponent$1(uid, state) {
	  return _unsafeGetComponent(uid, getGameObjectData(state)[/* materialMap */8]);
	}

	function addMaterialComponent$1(uid, component, state) {
	  _addComponent(uid, component, getGameObjectData(state)[/* materialMap */8]);
	  var match = getGameObject$3(component, state);
	  if (match) {
	    return increaseGroupCount$2(component, state);
	  } else {
	    return handleAddComponent$3(component, uid, state);
	  }
	}

	function disposeMaterialComponent$1(_, component, state) {
	  return handleDisposeComponent$2(component, state);
	}

	function _batchGetComponent(uidArray, componentMap, _) {
	  return reduceOneParam((function (arr, uid) {
	                var match = get$3(uid, componentMap);
	                if (match) {
	                  arr.push(match[0]);
	                  return arr;
	                } else {
	                  return arr;
	                }
	              }), /* int array */[], uidArray);
	}

	function batchGetTransformComponent(uidArray, state) {
	  return _batchGetComponent(uidArray, getGameObjectData(state)[/* transformMap */4], state);
	}

	function _batchDisposeComponent(uidMap, state, handleFunc, componentArray) {
	  return handleFunc(componentArray, uidMap, state);
	}

	function batchDisposeTransformComponent(uidMap, state, componentArray) {
	  return _batchDisposeComponent(uidMap, state, handleBatchDisposeComponent, componentArray);
	}

	function batchGetMeshRendererComponent(uidArray, state) {
	  return _batchGetComponent(uidArray, getGameObjectData(state)[/* meshRendererMap */7], state);
	}

	function batchDisposeMeshRendererComponent(uidMap, state, componentArray) {
	  return _batchDisposeComponent(uidMap, state, handleBatchDisposeComponent$3, componentArray);
	}

	function batchGetMaterialComponent(uidArray, state) {
	  return _batchGetComponent(uidArray, getGameObjectData(state)[/* materialMap */8], state);
	}

	function batchDisposeMaterialComponent(uidMap, state, componentArray) {
	  return _batchDisposeComponent(uidMap, state, handleBatchDisposeComponent$2, componentArray);
	}

	function batchGetGeometryComponent(uidArray, state) {
	  return _batchGetComponent(uidArray, getGameObjectData(state)[/* geometryMap */6], state);
	}

	function batchDisposeGeometryComponent(uidMap, state, componentArray) {
	  return _batchDisposeComponent(uidMap, state, handleBatchDisposeComponent$1, componentArray);
	}

	function batchGetCameraControllerComponent(uidArray, state) {
	  return _batchGetComponent(uidArray, getGameObjectData(state)[/* cameraControllerMap */5], state);
	}

	function batchDisposeCameraControllerComponent(uidMap, state, componentArray) {
	  return _batchDisposeComponent(uidMap, state, handleBatchDisposeComponent$6, componentArray);
	}

	function batchGetSourceInstanceComponent(uidArray, state) {
	  return _batchGetComponent(uidArray, getGameObjectData(state)[/* sourceInstanceMap */9], state);
	}

	function batchDisposeSourceInstanceComponent(uidMap, state, disposeGameObjectFunc, componentArray) {
	  return handleBatchDisposeComponent$5(componentArray, uidMap, disposeGameObjectFunc, state);
	}

	function batchGetObjectInstanceComponent(uidArray, state) {
	  return _batchGetComponent(uidArray, getGameObjectData(state)[/* objectInstanceMap */10], state);
	}

	function batchDisposeObjectInstanceComponent(uidMap, state, componentArray) {
	  var match = componentArray.length;
	  if (match !== 0) {
	    return _batchDisposeComponent(uidMap, state, handleBatchDisposeComponent$4, componentArray);
	  } else {
	    return state;
	  }
	}

	function _batchAddComponent(uidArray, componentArr, componentMap, handleAddComponentFunc, state) {
	  requireCheck((function () {
	          return test("one gameObject should add one component", (function () {
	                        return Operators[/* = */0](uidArray.length, componentArr.length);
	                      }));
	        }));
	  return reduceOneParami((function (state, uid, index) {
	                var component = componentArr[index];
	                _addComponent(uid, component, componentMap);
	                return handleAddComponentFunc(component, uid, state);
	              }), state, uidArray);
	}

	function _batchAddSharableComponent(uidArray, componentArr, componentMap, increaseGroupCountFunc, state) {
	  requireCheck((function () {
	          return test("one gameObject should add one component", (function () {
	                        return Operators[/* = */0](uidArray.length, componentArr.length);
	                      }));
	        }));
	  return reduceOneParami((function (state, uid, index) {
	                var component = componentArr[index];
	                _addComponent(uid, component, componentMap);
	                return increaseGroupCountFunc(component, state);
	              }), state, uidArray);
	}

	function batchAddTransformComponentForClone(uidArray, componentArr, state) {
	  return _batchAddComponent(uidArray, componentArr, getGameObjectData(state)[/* transformMap */4], handleAddComponent$1, state);
	}

	function batchAddMeshRendererComponentForClone(uidArray, componentArr, state) {
	  return _batchAddComponent(uidArray, componentArr, getGameObjectData(state)[/* meshRendererMap */7], handleAddComponent$4, state);
	}

	function batchAddGeometryComponentForClone(uidArray, componentArr, state) {
	  return _batchAddSharableComponent(uidArray, componentArr, getGameObjectData(state)[/* geometryMap */6], increaseGroupCount, state);
	}

	function batchAddMaterialComponentForClone(uidArray, componentArr, isShareMaterial, state) {
	  var componentMap = getGameObjectData(state)[/* materialMap */8];
	  if (isShareMaterial !== 0) {
	    return _batchAddSharableComponent(uidArray, componentArr, componentMap, increaseGroupCount$2, state);
	  } else {
	    return _batchAddComponent(uidArray, componentArr, componentMap, handleAddComponent$3, state);
	  }
	}

	function batchAddCameraControllerComponentForClone(uidArray, componentArr, state) {
	  return _batchAddComponent(uidArray, componentArr, getGameObjectData(state)[/* cameraControllerMap */5], handleAddComponent$7, state);
	}

	var cloneTransformComponent = handleCloneComponent$2;

	function cloneMeshRendererComponent(_, countRangeArr, state) {
	  return handleCloneComponent$3(countRangeArr, state);
	}

	var cloneGeometryComponent = handleCloneComponent;

	var cloneMaterialComponent = handleCloneComponent$1;

	var cloneCameraControllerComponent = handleCloneComponent$4;


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var hasSourceInstanceComponent$1 = hasSourceInstanceComponent$2;


	/* GameObjectComponentCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function isSupportInstance(state) {
	  if (getConfig$1(state)[/* useHardwareInstance */0]) {
	    return hasExtension(getGpuDetectData(state)[/* extensionInstancedArrays */0]);
	  } else {
	    return /* false */0;
	  }
	}

	var isSourceInstance = hasSourceInstanceComponent$1;


	/* GameObjectAdminAci2-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getInitPipelines(state) {
	  return state[/* renderConfig */3][/* init_pipelines */2];
	}

	function getInitJobs(state) {
	  return state[/* renderConfig */3][/* init_jobs */4];
	}

	function getRenderPipelines(state) {
	  return state[/* renderConfig */3][/* render_pipelines */3];
	}

	function getRenderJobs(state) {
	  return state[/* renderConfig */3][/* render_jobs */5];
	}

	function getShaders(state) {
	  return state[/* renderConfig */3][/* shaders */6];
	}

	function getShaderLibs(state) {
	  return state[/* renderConfig */3][/* shader_libs */7];
	}

	function getRenderSetting(state) {
	  return state[/* renderConfig */3][/* render_setting */1];
	}

	function findFirst(arr, func) {
	  return ensureCheck((function () {
	                return test("should find result", (function () {
	                              return assertExist(undefined_to_opt(arr.find(__1(func))));
	                            }));
	              }), arr.find(func));
	}

	function _getExecutableJob(jobs, param) {
	  var jobItemName = param[/* name */0];
	  var match = findFirst(jobs, (function (param) {
	          return caml_equal(param[/* name */0], jobItemName);
	        }));
	  return /* record */[
	          /* name */jobItemName,
	          /* flags */param[/* flags */1],
	          /* shader */match[/* shader */1]
	        ];
	}

	function getInitPipelineExecutableJobs(param, init_pipelines, jobs) {
	  var init_pipeline = param[/* init_pipeline */3];
	  var init_pipelineItem = findFirst(init_pipelines, (function (param) {
	          return caml_equal(param[/* name */0], init_pipeline);
	        }));
	  return init_pipelineItem[/* jobs */1].map((function (param) {
	                return _getExecutableJob(jobs, param);
	              }));
	}

	function getRenderPipelineExecutableJobs(param, render_pipelines, jobs) {
	  var render_pipeline = param[/* render_pipeline */4];
	  var render_pipelineItem = findFirst(render_pipelines, (function (param) {
	          return caml_equal(param[/* name */0], render_pipeline);
	        }));
	  return render_pipelineItem[/* jobs */1].map((function (param) {
	                return _getExecutableJob(jobs, param);
	              }));
	}

	function execJobs(gl, jobs, state) {
	  var jobHandleMap = state[/* renderConfig */3][/* jobHandleMap */0];
	  return reduceState((function (state, param) {
	                var match = get$2(param[/* name */0], jobHandleMap);
	                if (match) {
	                  return _3(match[0], /* tuple */[
	                              param[/* flags */1],
	                              param[/* shader */2]
	                            ], gl, state);
	                } else {
	                  return state;
	                }
	              }), state, jobs);
	}

	function _findFirstShaderData(shaderLibName, shaderLibs) {
	  return findFirst(shaderLibs, (function (item) {
	                return caml_equal(item[/* name */0], shaderLibName);
	              }));
	}

	function getMaterialShaderLibDataArr(param, gameObject, shaderLibItems, shaderLibs, state) {
	  var groups = param[/* groups */1];
	  var static_branchs = param[/* static_branchs */0];
	  return reduceOneParam((function (resultDataArr, param) {
	                var name = param[/* name */1];
	                var type_ = param[/* type_ */0];
	                if (type_) {
	                  switch (type_[0]) {
	                    case "group" : 
	                        var group = findFirst(groups, (function (item) {
	                                return caml_equal(item[/* name */0], name);
	                              }));
	                        var shaderLibArr = group[/* value */1].map((function (name) {
	                                return _findFirstShaderData(name, shaderLibs);
	                              }));
	                        return resultDataArr.concat(shaderLibArr);
	                    case "static_branch" : 
	                        var match = findFirst(static_branchs, (function (item) {
	                                return caml_equal(item[/* name */0], name);
	                              }));
	                        var value = match[/* value */1];
	                        if (name === "modelMatrix_instance") {
	                          var shaderLibName = isSourceInstance(gameObject, state) ? (
	                              isSupportInstance(state) ? caml_array_get(value, 1) : caml_array_get(value, 2)
	                            ) : caml_array_get(value, 0);
	                          resultDataArr.push(_findFirstShaderData(shaderLibName, shaderLibs));
	                          return resultDataArr;
	                        } else {
	                          throw [
	                                match_failure,
	                                [
	                                  "/Users/y/Github/Wonder.js/src/renderer/config/render/RenderConfigSystem.re",
	                                  100,
	                                  15
	                                ]
	                              ];
	                        }
	                        break;
	                    default:
	                      throw [
	                            match_failure,
	                            [
	                              "/Users/y/Github/Wonder.js/src/renderer/config/render/RenderConfigSystem.re",
	                              90,
	                              13
	                            ]
	                          ];
	                  }
	                } else {
	                  resultDataArr.push(_findFirstShaderData(name, shaderLibs));
	                  return resultDataArr;
	                }
	              }), createEmpty(/* () */0), shaderLibItems);
	}

	function throwJobFlagsShouldBeDefined() {
	  return throwMessage("jobFlags should be defined");
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _initMaterialShader(gl, materialIndex, initShaderFuncTuple, state) {
	  var shaderData = getShaders(state);
	  var shader_libs = shaderData[/* basic_material */2][/* material_shader */0][/* shader_libs */0];
	  var shaderLibs = getShaderLibs(state);
	  var gameObject = unsafeGetGameObject(materialIndex, state);
	  var match = hasShaderIndex(materialIndex, state);
	  if (match !== 0) {
	    return state;
	  } else {
	    var shaderIndex = initMaterialShader(gl, materialIndex, getMaterialShaderLibDataArr(shaderData, gameObject, shader_libs, shaderLibs, state), initShaderFuncTuple, state);
	    return setShaderIndex$1(materialIndex, shaderIndex, state);
	  }
	}

	function initMaterial(gl, materialIndex, state) {
	  return _initMaterialShader(gl, materialIndex, buildGLSLSource, state);
	}

	var handleInitComponent$1 = initMaterial;


	/* ShaderSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var getGameObject$2 = getGameObject$3;

	var isAlive$4 = isAlive$6;

	var unsafeGetColor$2 = unsafeGetColor$1;

	function setColor$1(material, color, state) {
	  set$1(material, color, getMaterialData(state)[/* colorMap */2]);
	  return state;
	}

	var handleInitComponent = handleInitComponent$1;

	var getMaterialData$1 = getMaterialData;

	var unsafeGetShaderIndex$1 = unsafeGetShaderIndex$2;

	var deepCopyStateForRestore$13 = deepCopyStateForRestore$10;

	var restore$14 = restore$10;


	/* MaterialStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function pregetGLSLData(_, state) {
	  var glslData = getGLSLData(state);
	  glslData[/* precision */0] = /* Some */[getPrecisionSource(state)];
	  return state;
	}

	var initData$1 = initData$3;

	function initMaterials(materialIndexArr, gl, state) {
	  return reduceState((function (state, materialIndex) {
	                return initMaterial(gl, materialIndex, state);
	              }), state, materialIndexArr);
	}

	function restore(gl, currentState, targetState) {
	  var newState = restore$14(currentState, targetState);
	  return initMaterials(getValidKeys(getMaterialData$1(newState)[/* gameObjectMap */3]), gl, newState);
	}

	var unsafeGetShaderIndex = unsafeGetShaderIndex$1;

	var deepCopyStateForRestore$2 = deepCopyStateForRestore$13;


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$4(state) {
	  state[/* geometryData */14] = /* Some */[/* record */[
	      /* index */0,
	      /* verticesMap */createEmpty$2(/* () */0),
	      /* indicesMap */createEmpty$2(/* () */0),
	      /* computeDataFuncMap */createEmpty$2(/* () */0),
	      /* configDataMap */createEmpty$2(/* () */0),
	      /* gameObjectMap */createEmpty$2(/* () */0),
	      /* disposedIndexArray */createEmpty(/* () */0),
	      /* isInitMap */createEmpty$2(/* () */0),
	      /* groupCountMap */createEmpty$2(/* () */0)
	    ]];
	  return state;
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function deepCopyStateForRestore$22(state) {
	  var match = getGeometryData(state);
	  var index = match[/* index */0];
	  var computeDataFuncMap = match[/* computeDataFuncMap */3];
	  var configDataMap = match[/* configDataMap */4];
	  var gameObjectMap = match[/* gameObjectMap */5];
	  var disposedIndexArray = match[/* disposedIndexArray */6];
	  var isInitMap = match[/* isInitMap */7];
	  var groupCountMap = match[/* groupCountMap */8];
	  var newrecord = state.slice();
	  newrecord[/* geometryData */14] = /* Some */[/* record */[
	      /* index */index,
	      /* verticesMap */copy$1(match[/* verticesMap */1]),
	      /* indicesMap */copy$1(match[/* indicesMap */2]),
	      /* computeDataFuncMap */copy$1(computeDataFuncMap),
	      /* configDataMap */copy$1(configDataMap),
	      /* gameObjectMap */copy$1(gameObjectMap),
	      /* disposedIndexArray */disposedIndexArray.slice(),
	      /* isInitMap */copy$1(isInitMap),
	      /* groupCountMap */copy$1(groupCountMap)
	    ]];
	  return newrecord;
	}

	function restore$19(currentState, sharedData, targetState) {
	  var match = getGeometryData(currentState);
	  var match$1 = addAllTypeArrayToPool$1(getMaxTypeArrayPoolSize(targetState), match[/* verticesMap */1], match[/* indicesMap */2], sharedData[/* float32ArrayPoolMap */1], sharedData[/* uint16ArrayPoolMap */2]);
	  return /* tuple */[
	          targetState,
	          /* record */[
	            /* gl */sharedData[/* gl */0],
	            /* float32ArrayPoolMap */match$1[0],
	            /* uint16ArrayPoolMap */match$1[1]
	          ]
	        ];
	}


	/* SparseMapSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getVertices$1(index, state) {
	  var match = getGeometryData(state);
	  return get$3(index, match[/* verticesMap */1]);
	}

	function unsafeGetVertices$1(index, state) {
	  var match = getGeometryData(state);
	  var verticesMap = match[/* verticesMap */1];
	  return ensureCheck((function () {
	                return test("vertices should exist", (function () {
	                              return assertExist(get$3(index, verticesMap));
	                            }));
	              }), unsafeGet$1(index, verticesMap));
	}

	function setVerticesWithArray(index, data, state) {
	  var match = getGeometryData(state);
	  var match$1 = getVertices$1(index, state);
	  if (match$1) {
	    fillFloat32Array(match$1[0], data, 0);
	    return state;
	  } else {
	    var match$2 = getFloat32TypeArrayFromPool(data.length, state);
	    var typeArr = match$2 ? fillFloat32Array(match$2[0], data, 0) : new Float32Array(data);
	    set$1(index, typeArr, match[/* verticesMap */1]);
	    return state;
	  }
	}

	function setVertices$1(index, data, state) {
	  var match = getGeometryData(state);
	  set$1(index, data, match[/* verticesMap */1]);
	  return state;
	}

	function getIndices$1(index, state) {
	  var match = getGeometryData(state);
	  return get$3(index, match[/* indicesMap */2]);
	}

	function unsafeGetIndices$1(index, state) {
	  var match = getGeometryData(state);
	  var indicesMap = match[/* indicesMap */2];
	  return ensureCheck((function () {
	                return test("indices should exist", (function () {
	                              return assertExist(get$3(index, indicesMap));
	                            }));
	              }), unsafeGet$1(index, indicesMap));
	}

	function getIndicesCount$1(index, state) {
	  return unsafeGetIndices$1(index, state).length;
	}

	function setIndicesWithArray(index, data, state) {
	  var match = getGeometryData(state);
	  var match$1 = getIndices$1(index, state);
	  if (match$1) {
	    fillUint16Array(match$1[0], data, 0);
	    return state;
	  } else {
	    var match$2 = getUint16TypeArrayFromPool(data.length, state);
	    var typeArr = match$2 ? fillUint16Array(match$2[0], data, 0) : new Uint16Array(data);
	    set$1(index, typeArr, match[/* indicesMap */2]);
	    return state;
	  }
	}

	function setIndices$1(index, data, state) {
	  var match = getGeometryData(state);
	  set$1(index, data, match[/* indicesMap */2]);
	  return state;
	}


	/* TypeArrayPoolSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getConfigData$1(geometry, state) {
	  return get$3(geometry, getGeometryData(state)[/* configDataMap */4]);
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _isInit(index, state) {
	  var match = get$3(index, getGeometryData(state)[/* isInitMap */7]);
	  if (match) {
	    return match[0];
	  } else {
	    return /* false */0;
	  }
	}

	function _markIsInit(index, isInit, state) {
	  set$1(index, isInit, getGeometryData(state)[/* isInitMap */7]);
	  return state;
	}

	function initGeometry(index, state) {
	  if (_isInit(index, state)) {
	    return state;
	  } else {
	    var match = getGeometryData(state);
	    var computeDataFuncMap = match[/* computeDataFuncMap */3];
	    var match$1 = get$3(index, computeDataFuncMap);
	    if (match$1) {
	      var match$2 = _2(match$1[0], index, state);
	      return _markIsInit(index, /* true */1, setIndicesWithArray(index, match$2[/* indices */1], setVerticesWithArray(index, match$2[/* vertices */0], state)));
	    } else {
	      return state;
	    }
	  }
	}

	var handleInitComponent$3 = initGeometry;


	/* GeometryOperateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var unsafeGetVertices = unsafeGetVertices$1;

	var setVertices = setVertices$1;

	var unsafeGetIndices = unsafeGetIndices$1;

	var setIndices = setIndices$1;

	var getIndicesCount = getIndicesCount$1;

	function getDrawMode(gl) {
	  return gl.TRIANGLES;
	}

	function getIndexType(gl) {
	  return gl.UNSIGNED_SHORT;
	}

	function getIndexTypeSize() {
	  return Uint16Array.BYTES_PER_ELEMENT;
	}

	function init$3(state) {
	  requireCheck((function () {
	          return test("shouldn't dispose any geometry before init", (function () {
	                        return assertTrue(isNotDisposed(getGeometryData(state)));
	                      }));
	        }));
	  var match = getGeometryData(state);
	  var index = match[/* index */0];
	  range(0, index - 1 | 0).forEach((function (geometryIndex) {
	          initGeometry(geometryIndex, state);
	          return /* () */0;
	        }));
	  return state;
	}

	var getConfigData = getConfigData$1;

	var getGameObject$6 = getGameObject$4;

	var isAlive$11 = isAlive$5;

	var handleInitComponent$2 = handleInitComponent$3;

	var deepCopyStateForRestore$21 = deepCopyStateForRestore$22;

	var restore$18 = restore$19;


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var getData = getGameObjectData;


	/* GameObjectStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function reAllocateGameObject(state) {
	  var data = getData(state);
	  var disposedUidMap = data[/* disposedUidMap */2];
	  var aliveUidArray = data[/* aliveUidArray */3];
	  var transformMap = data[/* transformMap */4];
	  var cameraControllerMap = data[/* cameraControllerMap */5];
	  var geometryMap = data[/* geometryMap */6];
	  var meshRendererMap = data[/* meshRendererMap */7];
	  var materialMap = data[/* materialMap */8];
	  var sourceInstanceMap = data[/* sourceInstanceMap */9];
	  var objectInstanceMap = data[/* objectInstanceMap */10];
	  var newTransformMap = createEmpty$2(/* () */0);
	  var newMeshRendererMap = createEmpty$2(/* () */0);
	  var newGeometryMap = createEmpty$2(/* () */0);
	  var newCameraControllerMap = createEmpty$2(/* () */0);
	  var newMaterialMap = createEmpty$2(/* () */0);
	  var newSourceInstanceMap = createEmpty$2(/* () */0);
	  var newObjectInstanceMap = createEmpty$2(/* () */0);
	  var newAliveUidArray = aliveUidArray.filter((function (aliveUid) {
	          return 1 - isDisposed(aliveUid, disposedUidMap);
	        }));
	  forEach((function (uid) {
	          set$1(uid, unsafeGet$1(uid, transformMap), newTransformMap);
	          var match = get$3(uid, meshRendererMap);
	          if (match) {
	            set$1(uid, match[0], newMeshRendererMap);
	          }
	          var match$1 = get$3(uid, geometryMap);
	          if (match$1) {
	            set$1(uid, match$1[0], newGeometryMap);
	          }
	          var match$2 = get$3(uid, materialMap);
	          if (match$2) {
	            set$1(uid, match$2[0], newMaterialMap);
	          }
	          var match$3 = get$3(uid, cameraControllerMap);
	          if (match$3) {
	            set$1(uid, match$3[0], newCameraControllerMap);
	          }
	          var match$4 = get$3(uid, sourceInstanceMap);
	          if (match$4) {
	            set$1(uid, match$4[0], newSourceInstanceMap);
	          }
	          var match$5 = get$3(uid, objectInstanceMap);
	          if (match$5) {
	            set$1(uid, match$5[0], newObjectInstanceMap);
	            return /* () */0;
	          } else {
	            return /* () */0;
	          }
	        }), newAliveUidArray);
	  data[/* disposedUidMap */2] = createEmpty$2(/* () */0);
	  data[/* aliveUidArray */3] = newAliveUidArray;
	  data[/* transformMap */4] = newTransformMap;
	  data[/* meshRendererMap */7] = newMeshRendererMap;
	  data[/* geometryMap */6] = newGeometryMap;
	  data[/* materialMap */8] = newMaterialMap;
	  data[/* cameraControllerMap */5] = newCameraControllerMap;
	  data[/* sourceInstanceMap */9] = newSourceInstanceMap;
	  data[/* objectInstanceMap */10] = newObjectInstanceMap;
	  return state;
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$5(state) {
	  state[/* transformData */11] = /* Some */[/* record */[
	      /* index */0,
	      /* parentMap */createEmpty$2(/* () */0),
	      /* childMap */createEmpty$2(/* () */0),
	      /* gameObjectMap */createEmpty$2(/* () */0),
	      /* localToWorldMatrixMap */createEmpty$2(/* () */0),
	      /* localPositionMap */createEmpty$2(/* () */0),
	      /* dirtyMap */createEmpty$2(/* () */0),
	      /* disposedIndexArray */createEmpty(/* () */0)
	    ]];
	  return state;
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGl(state) {
	  return getExn(state[/* deviceManagerData */9][/* gl */0]);
	}

	function setGl(gl, state) {
	  var newrecord = state.slice();
	  var init = state[/* deviceManagerData */9];
	  newrecord[/* deviceManagerData */9] = /* record */[
	    /* gl : Some */[gl],
	    /* colorWrite */init[/* colorWrite */1],
	    /* clearColor */init[/* clearColor */2]
	  ];
	  return newrecord;
	}

	var createGL = getContext;

	function setColorWrite(gl, writeRed, writeGreen, writeBlue, writeAlpha, state) {
	  var match = state[/* deviceManagerData */9];
	  var colorWrite = match[/* colorWrite */1];
	  var exit = 0;
	  if (colorWrite) {
	    var match$1 = colorWrite[0];
	    if (caml_equal(match$1[0], writeRed) && caml_equal(match$1[1], writeGreen) && caml_equal(match$1[2], writeBlue) && caml_equal(match$1[3], writeAlpha)) {
	      return state;
	    } else {
	      exit = 1;
	    }
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
	    var newrecord = state.slice();
	    var init = state[/* deviceManagerData */9];
	    newrecord[/* deviceManagerData */9] = /* record */[
	      /* gl */init[/* gl */0],
	      /* colorWrite : Some */[/* tuple */[
	          writeRed,
	          writeGreen,
	          writeBlue,
	          writeAlpha
	        ]],
	      /* clearColor */init[/* clearColor */2]
	    ];
	    return newrecord;
	  }
	  
	}

	function clearBuffer(gl, bit, state) {
	  var state$1 = setColorWrite(gl, true, true, true, true, state);
	  gl.clear(bit);
	  return state$1;
	}

	function clearColor(gl, param, state) {
	  var a = param[3];
	  var b = param[2];
	  var g = param[1];
	  var r = param[0];
	  var match = state[/* deviceManagerData */9];
	  var clearColor$1 = match[/* clearColor */2];
	  var exit = 0;
	  if (clearColor$1) {
	    var match$1 = clearColor$1[0];
	    if (match$1[0] === r && match$1[1] === g && match$1[2] === b && match$1[3] === a) {
	      return state;
	    } else {
	      exit = 1;
	    }
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    gl.clearColor(r, g, b, a);
	    var newrecord = state.slice();
	    var init = state[/* deviceManagerData */9];
	    newrecord[/* deviceManagerData */9] = /* record */[
	      /* gl */init[/* gl */0],
	      /* colorWrite */init[/* colorWrite */1],
	      /* clearColor : Some */[/* tuple */[
	          r,
	          g,
	          b,
	          a
	        ]]
	    ];
	    return newrecord;
	  }
	  
	}

	function deepCopyStateForRestore$23(state) {
	  var match = state[/* deviceManagerData */9];
	  var newrecord = state.slice();
	  newrecord[/* deviceManagerData */9] = /* record */[
	    /* gl : None */0,
	    /* colorWrite */match[/* colorWrite */1],
	    /* clearColor */match[/* clearColor */2]
	  ];
	  return newrecord;
	}

	function restore$20(_, param, targetState) {
	  var newrecord = targetState.slice();
	  var init = targetState[/* deviceManagerData */9];
	  newrecord[/* deviceManagerData */9] = /* record */[
	    /* gl : Some */[param[/* gl */0]],
	    /* colorWrite */init[/* colorWrite */1],
	    /* clearColor */init[/* clearColor */2]
	  ];
	  return newrecord;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var create$8 = create$7;

	function getCurrentCameraController(state) {
	  requireCheck((function () {
	          return test("should has at least one camera", (function () {
	                        var match = getCameraControllerData(state);
	                        var cameraArray = match[/* cameraArray */1];
	                        return Operators[/* > */5](cameraArray.length, 0);
	                      }));
	        }));
	  var match = getCameraControllerData(state);
	  var cameraArray = match[/* cameraArray */1];
	  return get$1(0, cameraArray);
	}

	function init$4(state) {
	  var cameraControllerData = getCameraControllerData(state);
	  var dirtyArray = cameraControllerData[/* dirtyArray */2];
	  var match = dirtyArray.length;
	  if (match !== 0) {
	    removeDuplicateItems(dirtyArray).forEach((function (dirtyIndex) {
	            init$2(dirtyIndex, cameraControllerData);
	            return /* () */0;
	          }));
	    return state;
	  } else {
	    return state;
	  }
	}

	function setPerspectiveCamera(cameraController, state) {
	  var cameraControllerData = getCameraControllerData(state);
	  set$1(cameraController, update$2, cameraControllerData[/* updateCameraFuncMap */5]);
	  return state;
	}

	function _updateCamera(index, cameraControllerData) {
	  var updateFunc = unsafeGet$1(index, cameraControllerData[/* updateCameraFuncMap */5]);
	  _2(updateFunc, index, cameraControllerData);
	  return /* () */0;
	}

	function update$3(state) {
	  var cameraControllerData = getCameraControllerData(state);
	  var dirtyArray = cameraControllerData[/* dirtyArray */2];
	  removeDuplicateItems(dirtyArray).forEach((function (dirtyIndex) {
	          return _updateCamera(dirtyIndex, cameraControllerData);
	        }));
	  cleanDirtyArray(cameraControllerData);
	  return state;
	}

	function getGameObject$7(cameraController, state) {
	  return getComponentGameObject(cameraController, getCameraControllerData(state)[/* gameObjectMap */4]);
	}

	function getWorldToCameraMatrix(transform, state) {
	  return invert(getLocalToWorldMatrixTypeArray$1(transform, state), createIdentityMatrix4(/* () */0));
	}

	function getPMatrix(cameraController, state) {
	  return ensureCheck((function () {
	                return test("pMatrix should exist", (function () {
	                              return assertExist(get$3(cameraController, getCameraControllerData(state)[/* pMatrixMap */3]));
	                            }));
	              }), unsafeGet$1(cameraController, getCameraControllerData(state)[/* pMatrixMap */3]));
	}

	var isAlive$12 = isAlive$10;

	var deepCopyStateForRestore$24 = deepCopyStateForRestore$19;


	/* TransformSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function increase(uid) {
	  return uid + 1 | 0;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function create$9(state) {
	  var data = getGameObjectData(state);
	  var uid = data[/* uid */0];
	  var aliveUidArray = data[/* aliveUidArray */3];
	  data[/* uid */0] = increase(uid);
	  aliveUidArray.push(uid);
	  return /* tuple */[
	          state,
	          uid
	        ];
	}


	/* GameObjectStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function init$1(state) {
	  return init$3(init$4(state));
	}

	function initDataFromState(state) {
	  return initData$4(initData$1(initData$5(state)));
	}

	function update(_, state) {
	  return update$3(state);
	}

	function create(state) {
	  var match = create$9(state);
	  var uid = match[1];
	  var match$1 = create$2(match[0]);
	  return /* tuple */[
	          addTransformComponent$1(uid, match$1[1], match$1[0]),
	          uid
	        ];
	}

	function batchDispose(uidArray, state) {
	  var data = getGameObjectData(state);
	  var disposeCount = data[/* disposeCount */1];
	  var disposedUidMap = data[/* disposedUidMap */2];
	  var disposedUidMap$1 = buildMapFromArray(uidArray, disposedUidMap);
	  data[/* disposeCount */1] = disposeCount + uidArray.length | 0;
	  var state$1 = batchDisposeObjectInstanceComponent(disposedUidMap$1, state, batchGetObjectInstanceComponent(uidArray, batchDisposeSourceInstanceComponent(disposedUidMap$1, state, batchDispose, batchGetSourceInstanceComponent(uidArray, batchDisposeCameraControllerComponent(disposedUidMap$1, state, batchGetCameraControllerComponent(uidArray, batchDisposeGeometryComponent(disposedUidMap$1, state, batchGetGeometryComponent(uidArray, batchDisposeMaterialComponent(disposedUidMap$1, state, batchGetMaterialComponent(uidArray, batchDisposeTransformComponent(disposedUidMap$1, state, batchGetTransformComponent(uidArray, batchDisposeMeshRendererComponent(disposedUidMap$1, state, batchGetMeshRendererComponent(uidArray, state))))))))))))));
	  if (isDisposeTooMany(data[/* disposeCount */1], state$1)) {
	    data[/* disposeCount */1] = 0;
	    return reAllocateGameObject(state$1);
	  } else {
	    return state$1;
	  }
	}

	function dispose(uid, state) {
	  var data = getGameObjectData(state);
	  var disposeCount = data[/* disposeCount */1];
	  var disposedUidMap = data[/* disposedUidMap */2];
	  data[/* disposeCount */1] = disposeCount + 1 | 0;
	  set$1(uid, /* true */1, disposedUidMap);
	  var match = getTransformComponent$1(uid, state);
	  var state$1 = match ? disposeTransformComponent$1(uid, match[0], state) : state;
	  var match$1 = getMeshRendererComponent$1(uid, state$1);
	  var state$2 = match$1 ? disposeMeshRendererComponent$1(uid, match$1[0], state$1) : state$1;
	  var match$2 = getMaterialComponent$1(uid, state$2);
	  var state$3 = match$2 ? disposeMaterialComponent$1(uid, match$2[0], state$2) : state$2;
	  var match$3 = getGeometryComponent$1(uid, state$3);
	  var state$4 = match$3 ? disposeGeometryComponent$1(uid, match$3[0], state$3) : state$3;
	  var match$4 = getCameraControllerComponent$1(uid, state$4);
	  var state$5 = match$4 ? disposeCameraControllerComponent$1(uid, match$4[0], state$4) : state$4;
	  var match$5 = getSourceInstanceComponent$1(uid, state$5);
	  var state$6 = match$5 ? disposeSourceInstanceComponent$1(uid, match$5[0], batchDispose, state$5) : state$5;
	  var match$6 = getObjectInstanceComponent$1(uid, state$6);
	  var state$7 = match$6 ? disposeObjectInstanceComponent$1(uid, match$6[0], state$6) : state$6;
	  if (isDisposeTooMany(data[/* disposeCount */1], state$7)) {
	    data[/* disposeCount */1] = 0;
	    return reAllocateGameObject(state$7);
	  } else {
	    return state$7;
	  }
	}

	function clone(uid, count, isShareMaterial, state) {
	  requireCheck((function () {
	          test("shouldn't clone sourceInstance gameObject", (function () {
	                  return assertFalse(hasSourceInstanceComponent$2(uid, state));
	                }));
	          return test("shouldn't clone objectInstance gameObject", (function () {
	                        return assertFalse(hasObjectInstanceComponent$1(uid, state));
	                      }));
	        }));
	  var countRangeArr = range(0, count - 1 | 0);
	  var totalClonedGameObjectArr = /* array */[];
	  var _clone = function (uid, transform, countRangeArr, clonedParentTransformArr, totalClonedGameObjectArr, state) {
	    var clonedGameObjectArr = /* array */[];
	    var state$1 = reduceState((function (state, _) {
	            var match = create$9(state);
	            clonedGameObjectArr.push(match[1]);
	            return match[0];
	          }), state, countRangeArr);
	    totalClonedGameObjectArr.push(clonedGameObjectArr);
	    var match = getMeshRendererComponent$1(uid, state$1);
	    var state$2;
	    if (match) {
	      var match$1 = cloneMeshRendererComponent(match[0], countRangeArr, state$1);
	      state$2 = batchAddMeshRendererComponentForClone(clonedGameObjectArr, match$1[1], match$1[0]);
	    } else {
	      state$2 = state$1;
	    }
	    var match$2 = getGeometryComponent$1(uid, state$2);
	    var state$3;
	    if (match$2) {
	      var match$3 = cloneGeometryComponent(match$2[0], countRangeArr, state$2);
	      state$3 = batchAddGeometryComponentForClone(clonedGameObjectArr, match$3[1], match$3[0]);
	    } else {
	      state$3 = state$2;
	    }
	    var match$4 = getMaterialComponent$1(uid, state$3);
	    var state$4;
	    if (match$4) {
	      var match$5 = cloneMaterialComponent(match$4[0], countRangeArr, isShareMaterial, state$3);
	      state$4 = batchAddMaterialComponentForClone(clonedGameObjectArr, match$5[1], isShareMaterial, match$5[0]);
	    } else {
	      state$4 = state$3;
	    }
	    var match$6 = getCameraControllerComponent$1(uid, state$4);
	    var state$5;
	    if (match$6) {
	      var match$7 = cloneCameraControllerComponent(match$6[0], countRangeArr, state$4);
	      state$5 = batchAddCameraControllerComponentForClone(clonedGameObjectArr, match$7[1], match$7[0]);
	    } else {
	      state$5 = state$4;
	    }
	    var match$8 = cloneTransformComponent(transform, countRangeArr, state$5);
	    var clonedTransformArr = match$8[1];
	    var state$6 = match$8[0];
	    batchAddTransformComponentForClone(clonedGameObjectArr, clonedTransformArr, state$6);
	    reduceState((function (state, childTransform) {
	            return _clone(getExn(getGameObject(childTransform, state)), childTransform, countRangeArr, clonedTransformArr, totalClonedGameObjectArr, state);
	          }), state$6, unsafeGetChildren(transform, reduceOneParami((function (transformData, clonedParentTransform, i) {
	                    return setParentNotMarkDirty(/* Some */[clonedParentTransform], caml_array_get(clonedTransformArr, i), transformData);
	                  }), getTransformData$1(state$6), clonedParentTransformArr)));
	    return state$6;
	  };
	  return /* tuple */[
	          _clone(uid, getExn(getTransformComponent$1(uid, state)), countRangeArr, /* int array */[], totalClonedGameObjectArr, state),
	          totalClonedGameObjectArr
	        ];
	}

	function isAlive(uid, state) {
	  var match = getGameObjectData(state);
	  var disposedUidMap = match[/* disposedUidMap */2];
	  var transformMap = match[/* transformMap */4];
	  var match$1 = has$1(uid, disposedUidMap);
	  if (match$1 !== 0) {
	    return /* false */0;
	  } else {
	    var match$2 = has$1(uid, transformMap);
	    if (match$2 !== 0) {
	      return /* true */1;
	    } else {
	      return /* false */0;
	    }
	  }
	}

	function initGameObject$1(uid, state) {
	  var match = getGeometryComponent$1(uid, state);
	  var state$1 = match ? handleInitComponent$2(match[0], state) : state;
	  var match$1 = getMaterialComponent$1(uid, state$1);
	  if (match$1) {
	    return handleInitComponent(getGl(state$1), match$1[0], state$1);
	  } else {
	    return state$1;
	  }
	}

	var hasSourceInstanceComponent = hasSourceInstanceComponent$2;

	var getSourceInstanceComponent = getSourceInstanceComponent$1;

	var addSourceInstanceComponent = addSourceInstanceComponent$1;

	var disposeSourceInstanceComponent = disposeSourceInstanceComponent$1;

	var getObjectInstanceComponent = getObjectInstanceComponent$1;

	var addObjectInstanceComponent = addObjectInstanceComponent$1;

	var disposeObjectInstanceComponent = disposeObjectInstanceComponent$1;

	var hasCameraControllerComponent = hasCameraControllerComponent$1;

	var getCameraControllerComponent = getCameraControllerComponent$1;

	var addCameraControllerComponent = addCameraControllerComponent$1;

	var disposeCameraControllerComponent = disposeCameraControllerComponent$1;

	var hasTransformComponent = hasTransformComponent$1;

	var getTransformComponent = getTransformComponent$1;

	var unsafeGetTransformComponent = unsafeGetTransformComponent$1;

	var addTransformComponent = addTransformComponent$1;

	var disposeTransformComponent = disposeTransformComponent$1;

	var hasGeometryComponent = hasGeometryComponent$1;

	var getGeometryComponent = getGeometryComponent$1;

	var unsafeGetGeometryComponent = unsafeGetGeometryComponent$1;

	var addGeometryComponent = addGeometryComponent$1;

	var disposeGeometryComponent = disposeGeometryComponent$1;

	var hasMeshRendererComponent = hasMeshRendererComponent$1;

	var getMeshRendererComponent = getMeshRendererComponent$1;

	var addMeshRendererComponent = addMeshRendererComponent$1;

	var disposeMeshRendererComponent = disposeMeshRendererComponent$1;

	var hasMaterialComponent = hasMaterialComponent$1;

	var getMaterialComponent = getMaterialComponent$1;

	var unsafeGetMaterialComponent = unsafeGetMaterialComponent$1;

	var addMaterialComponent = addMaterialComponent$1;

	var disposeMaterialComponent = disposeMaterialComponent$1;

	var deepCopyStateForRestore$1 = deepCopyStateForRestore$14;


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function setIsTest(isTest, stateData) {
	  stateData[/* isTest */1] = isTest;
	  return /* () */0;
	}


	/* No side effect */

	function flatten$1(param) {
	  if (param) {
	    return $at(param[0], flatten$1(param[1]));
	  } else {
	    return /* [] */0;
	  }
	}

	var concat$1 = flatten$1;


	/* No side effect */

	/* No side effect */

	function index_rec(s, lim, _i, c) {
	  while(true) {
	    var i = _i;
	    if (i >= lim) {
	      throw not_found;
	    } else if (s[i] === c) {
	      return i;
	    } else {
	      _i = i + 1 | 0;
	      continue ;
	      
	    }
	  }
	}

	function contains_from$1(s, i, c) {
	  var l = s.length;
	  if (i < 0 || i > l) {
	    throw [
	          invalid_argument,
	          "String.contains_from / Bytes.contains_from"
	        ];
	  } else {
	    try {
	      index_rec(s, l, i, c);
	      return /* true */1;
	    }
	    catch (exn){
	      if (exn === not_found) {
	        return /* false */0;
	      } else {
	        throw exn;
	      }
	    }
	  }
	}

	function contains$1(s, c) {
	  return contains_from$1(s, 0, c);
	}


	/* No side effect */

	function contains(s, c) {
	  return contains$1(bytes_of_string(s), c);
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function findFirstHtmlElement($$document, str) {
	  var elements = $$document.querySelectorAll(str);
	  var match = elements.length;
	  if (match !== 0) {
	    return /* Some */[caml_array_get(elements, 0)];
	  } else {
	    return /* None */0;
	  }
	}

	function setInnerHtml(eleStr, htmlElement) {
	  htmlElement.innerHTML = eleStr;
	  return htmlElement;
	}

	function getFirstChild(htmlElement) {
	  return htmlElement.firstChild;
	}

	function _prepend(sourceElement, targetElement) {
	  var match = targetElement.prepend;
	  if (match == null) {
	    return targetElement.insertBefore(sourceElement, targetElement.firstChild);
	  } else {
	    return targetElement.prepend(sourceElement);
	  }
	}

	function prependTo(sourceElement, targetElement) {
	  if (targetElement) {
	    var match = sourceElement.nodeType;
	    if (match !== 1) {
	      return sourceElement;
	    } else {
	      _prepend(sourceElement, targetElement[0]);
	      return sourceElement;
	    }
	  } else {
	    return failwith("targetElement should exist");
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function buildDom(domStr) {
	  return getFirstChild(setInnerHtml(domStr, document.createElement("div")));
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _getCanvasId(domId) {
	  var match = contains(domId, /* "#" */35);
	  if (match !== 0) {
	    return domId;
	  } else {
	    return ensureCheck((function (id) {
	                  return test("dom id should start with '#'", (function () {
	                                return assertTrue(+(/#[^#]+/).test(id));
	                              }));
	                }), "#" + (String(domId) + ""));
	  }
	}

	function createCanvas(param) {
	  var canvasId = param[/* canvasId */0];
	  if (canvasId) {
	    var canvasId$1 = canvasId[0];
	    var match = findFirstHtmlElement(document, _getCanvasId(canvasId$1));
	    if (match) {
	      return match[0];
	    } else {
	      return failwith("canvas whose id is " + (String(canvasId$1) + " should exist"));
	    }
	  } else {
	    var arg = findFirstHtmlElement(document, "body");
	    return (function (param) {
	                return prependTo(param, arg);
	              })(buildDom("<canvas></canvas>"));
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function setConfig$2(bufferConfig, state) {
	  var newrecord = state.slice();
	  newrecord[/* bufferConfig */0] = /* Some */[bufferConfig];
	  return newrecord;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _changeToContextConfigRecord(contextConfigObj) {
	  return /* record */[
	          /* alpha */+getValueFromJsObj(contextConfigObj.alpha, true),
	          /* depth */+getValueFromJsObj(contextConfigObj.depth, true),
	          /* stencil */+getValueFromJsObj(contextConfigObj.stencil, false),
	          /* antialias */+getValueFromJsObj(contextConfigObj.antialias, true),
	          /* premultipliedAlpha */+getValueFromJsObj(contextConfigObj.premultipliedAlpha, true),
	          /* preserveDrawingBuffer */+getValueFromJsObj(contextConfigObj.preserveDrawingBuffer, false)
	        ];
	}

	function _changeToBufferConfigRecord(bufferConfigObj) {
	  return /* record */[/* geometryPointDataBufferCount */getValueFromJsObj(bufferConfigObj.geometryPointDataBufferCount, 1000000)];
	}

	function _changeToGpuConfigRecord(gpuConfigObj) {
	  return /* record */[/* useHardwareInstance */+getValueFromJsObj(gpuConfigObj.useHardwareInstance, true)];
	}

	function _changeConfigToRecord(config) {
	  var match = config.contextConfig;
	  var match$1 = config.bufferConfig;
	  var match$2 = config.gpuConfig;
	  return /* record */[
	          /* canvasId */getOptionValueFromJsObj(config.canvasId),
	          /* isTest */+getValueFromJsObj(config.isTest, false),
	          /* contextConfig */(match == null) ? /* record */[
	              /* alpha : true */1,
	              /* depth : true */1,
	              /* stencil : false */0,
	              /* antialias : true */1,
	              /* premultipliedAlpha : true */1,
	              /* preserveDrawingBuffer : false */0
	            ] : _changeToContextConfigRecord(match),
	          /* bufferConfig */(match$1 == null) ? /* record */[/* geometryPointDataBufferCount */1000000] : _changeToBufferConfigRecord(match$1),
	          /* gpuConfig */(match$2 == null) ? /* record */[/* useHardwareInstance : true */1] : _changeToGpuConfigRecord(match$2)
	        ];
	}

	function setConfig(config, state) {
	  var config$1 = _changeConfigToRecord(config);
	  setIsTest(config$1[/* isTest */1], stateData);
	  return /* tuple */[
	          config$1,
	          state
	        ];
	}

	function init(param) {
	  var config = param[0];
	  var canvas = createCanvas(config);
	  var gl = createGL(canvas, config[/* contextConfig */2]);
	  return initDataFromState(detect(gl, setConfig$1(config[/* gpuConfig */4], setConfig$2(config[/* bufferConfig */3], setContextConfig(config[/* contextConfig */2], setCanvas(canvas, setGl(gl, param[1])))))));
	}


	/* GameObjectAdmin-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var shaders = "\n{\n  \"static_branchs\": [\n    {\n      \"name\": \"modelMatrix_instance\",\n      \"value\": [\n        \"modelMatrix_noInstance\",\n        \"modelMatrix_hardware_instance\",\n        \"modelMatrix_batch_instance\"\n      ]\n    }\n  ],\n  \"groups\": [\n    {\n      \"name\": \"top\",\n      \"value\": [\n        \"common\",\n        \"vertex\"\n      ]\n    },\n    {\n      \"name\": \"end\",\n      \"value\": [\n        \"end\"\n      ]\n    }\n  ],\n  \"basic_material\": {\n    \"material_shader\": {\n      \"shader_libs\": [\n        {\n          \"type\": \"group\",\n          \"name\": \"top\"\n        },\n        {\n          \"type\": \"static_branch\",\n          \"name\": \"modelMatrix_instance\"\n        },\n        {\n          \"name\": \"basic\"\n        },\n        {\n          \"name\": \"basic_end\"\n        },\n        {\n          \"type\": \"group\",\n          \"name\": \"end\"\n        }\n      ]\n    }\n  }\n}\n";


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var init_jobs = "\n    [\n        {\"name\": \"preget_glslData\"},\n        {\"name\": \"init_basic_material\"}\n    ]\n";


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var render_jobs = "\n[\n  {\"name\":\"get_render_array\"},\n  {\"name\":\"get_camera_data\"},\n  {\"name\":\"clear_color\"},\n  {\"name\":\"clear_buffer\"},\n  {\"name\":\"render_basic\"}\n]\n";


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var shader_libs = "\n[\n  {\n    \"name\": \"common\",\n    \"glsls\": [\n      {\n        \"type\": \"vs\",\n        \"name\": \"common_vertex\"\n      },\n      {\n        \"type\": \"fs\",\n        \"name\": \"common_fragment\"\n      }\n    ],\n    \"variables\": {\n      \"uniforms\": [\n        {\n          \"name\": \"u_vMatrix\",\n          \"field\": \"vMatrix\",\n          \"type\": \"mat4\",\n          \"from\": \"camera\"\n        },\n        {\n          \"name\": \"u_pMatrix\",\n          \"field\": \"pMatrix\",\n          \"type\": \"mat4\",\n          \"from\": \"camera\"\n        }\n      ]\n    }\n  },\n  {\n    \"name\": \"modelMatrix_noInstance\",\n    \"glsls\": [\n      {\n        \"type\": \"vs\",\n        \"name\": \"modelMatrix_noInstance_vertex\"\n      }\n    ],\n    \"variables\": {\n      \"uniforms\": [\n        {\n          \"name\": \"u_mMatrix\",\n          \"field\": \"mMatrix\",\n          \"type\": \"mat4\",\n          \"from\": \"model\"\n        }\n      ]\n    }\n  },\n  {\n    \"name\": \"modelMatrix_hardware_instance\",\n    \"glsls\": [\n      {\n        \"type\": \"vs\",\n        \"name\": \"modelMatrix_hardware_instance_vertex\"\n      }\n    ],\n    \"variables\": {\n      \"attributes\": [\n        {\n          \"name\": \"a_mVec4_0\",\n          \"buffer\": \"instance\",\n          \"type\": \"vec4\"\n        },\n        {\n          \"name\": \"a_mVec4_1\",\n          \"buffer\": \"instance\",\n          \"type\": \"vec4\"\n        },\n        {\n          \"name\": \"a_mVec4_2\",\n          \"buffer\": \"instance\",\n          \"type\": \"vec4\"\n        },\n        {\n          \"name\": \"a_mVec4_3\",\n          \"buffer\": \"instance\",\n          \"type\": \"vec4\"\n        }\n      ]\n    }\n  },\n  {\n    \"name\": \"modelMatrix_batch_instance\",\n    \"glsls\": [\n      {\n        \"type\": \"vs\",\n        \"name\": \"modelMatrix_batch_instance_vertex\"\n      }\n    ],\n    \"variables\": {\n      \"uniforms\": [\n        {\n          \"name\": \"u_mMatrix\",\n          \"field\": \"instance_mMatrix\",\n          \"type\": \"mat4\",\n          \"from\": \"model\"\n        }\n      ]\n    }\n  },\n  {\n    \"name\": \"vertex\",\n    \"variables\": {\n      \"attributes\": [\n        {\n          \"name\": \"a_position\",\n          \"buffer\": \"vertex\",\n          \"type\": \"vec3\"\n        }\n      ]\n    }\n  },\n  {\n    \"name\": \"basic\",\n    \"glsls\": [\n      {\n        \"type\": \"vs\",\n        \"name\": \"webgl1_basic_vertex\"\n      },\n      {\n        \"type\": \"fs\",\n        \"name\": \"webgl1_basic_fragment\"\n      }\n    ],\n    \"variables\": {\n      \"uniforms\": [\n        {\n          \"name\": \"u_color\",\n          \"field\": \"color\",\n          \"type\": \"vec3\",\n          \"from\": \"material\"\n        }\n      ]\n    }\n  },\n  {\n    \"name\": \"basic_end\",\n    \"glsls\": [\n      {\n        \"type\": \"fs\",\n        \"name\": \"webgl1_basic_end_fragment\"\n      }\n    ]\n  },\n  {\n    \"name\": \"end\",\n    \"variables\": {\n      \"attributes\": [\n        {\n          \"buffer\": \"index\"\n        }\n      ]\n    }\n  }\n]\n";


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$6() {
	  return /* record */[
	          /* index */0,
	          /* shaderIndexMap */createEmpty$1(/* () */0),
	          /* glslData : record */[/* precision : None */0]
	        ];
	}


	/* HashMapSystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var unsafeGetVertices$2 = unsafeGetVertices;

	var unsafeGetIndices$2 = unsafeGetIndices;

	var getDrawMode$1 = getDrawMode;

	var getIndexType$1 = getIndexType;

	var getIndexTypeSize$1 = getIndexTypeSize;

	var getIndicesCount$2 = getIndicesCount;

	var deepCopyStateForRestore$26 = deepCopyStateForRestore$21;

	var restore$22 = restore$18;


	/* GeometrySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$7() {
	  return /* record */[
	          /* programMap */createEmpty$2(/* () */0),
	          /* lastUsedProgram : None */0
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var init_pipelines = "\n  [\n  {\"name\": \"simple_basic_render\", \"jobs\": [\n    {\"name\": \"preget_glslData\"},\n    {\"name\": \"init_basic_material\"}\n    ]}\n]\n";


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var render_setting = "\n    {\n    \"platform\": \"pc\",\n    \"browser\": [\n        {\n            \"name\": \"chrome\",\n            \"version\": \"newest\"\n        },\n        {\n            \"name\": \"firefox\",\n            \"version\": \"newest\"\n        }\n    ],\n    \"backend\": {\n        \"name\": \"webgl1\"\n    },\n    \"init_pipeline\": \"simple_basic_render\",\n    \"render_pipeline\": \"simple_basic_render\"\n}\n";


	/* No side effect */

	function floor_int(f) {
	  if (f > max_int) {
	    return max_int;
	  } else if (f < min_int) {
	    return min_int;
	  } else {
	    return Math.floor(f);
	  }
	}

	var floor = floor_int;


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var hexFloat_of_string = (
	function(str) {
	    return parseInt(str, 16);
	}
	);

	function leastFloat(_, num) {
	  var match = +(num < 0);
	  if (match !== 0) {
	    return 0;
	  } else {
	    return num;
	  }
	}


	/* hexFloat_of_string Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var regex_num = (/^\#([0-9a-f]{6})$/i);

	function convert16HexToRGBA(hexStr) {
	  var match = regex_num.exec(hexStr);
	  if (match !== null) {
	    var match$1 = caml_array_get(match, 1);
	    if (match$1 == null) {
	      return throwMessage("color should be #xxxxxx");
	    } else {
	      var hex = floor(_1(hexFloat_of_string, match$1));
	      return /* tuple */[
	              ((hex >>> 16) & 255) / 255,
	              ((hex >>> 8) & 255) / 255,
	              (hex & 255) / 255,
	              1
	            ];
	    }
	  } else {
	    return throwMessage("color should be #xxxxxx");
	  }
	}


	/* regex_num Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getJob(param, gl, state) {
	  var flags = param[0];
	  if (flags) {
	    return clearColor(gl, convert16HexToRGBA(caml_array_get(flags[0], 0)), state);
	  } else {
	    return throwJobFlagsShouldBeDefined(/* () */0);
	  }
	}


	/* ColorSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _getBitFromFlags(gl, flags) {
	  var bit = /* None */0;
	  if (flags.includes("COLOR_BUFFER")) {
	    var match = bit;
	    bit = match ? /* Some */[match[0] | gl.COLOR_BUFFER_BIT] : /* Some */[gl.COLOR_BUFFER_BIT];
	  }
	  if (flags.includes("DEPTH_BUFFER")) {
	    var match$1 = bit;
	    bit = match$1 ? /* Some */[match$1[0] | gl.DEPTH_BUFFER_BIT] : /* Some */[gl.DEPTH_BUFFER_BIT];
	  }
	  if (flags.includes("STENCIL_BUFFER")) {
	    var match$2 = bit;
	    bit = match$2 ? /* Some */[match$2[0] | gl.STENCIL_BUFFER_BIT] : /* Some */[gl.STENCIL_BUFFER_BIT];
	  }
	  return getExn(bit);
	}

	function getJob$1(param, gl, state) {
	  var flags = param[0];
	  if (flags) {
	    return clearBuffer(gl, _getBitFromFlags(gl, flags[0]), state);
	  } else {
	    return throwJobFlagsShouldBeDefined(/* () */0);
	  }
	}


	/* RenderConfigSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE

	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var getGLSLSenderData$1 = getGLSLSenderData;

	var deepCopyStateForRestore$27 = deepCopyStateForRestore$12;

	var restore$23 = restore$13;


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function createBuffer(gl, data, state) {
	  var buffer = getArrayBuffer(gl, state);
	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
	  gl.bindBuffer(gl.ARRAY_BUFFER, null);
	  return buffer;
	}

	function getOrCreateBuffer$1(gl, geometryIndex, bufferMap, getDataFunc, state) {
	  return getOrCreateBuffer(gl, geometryIndex, bufferMap, createBuffer, getDataFunc, state);
	}


	/* VboBufferSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function createBuffer$1(gl, data, state) {
	  var buffer = getElementArrayBuffer(gl, state);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	  return buffer;
	}

	function getOrCreateBuffer$2(gl, geometryIndex, bufferMap, getDataFunc, state) {
	  return getOrCreateBuffer(gl, geometryIndex, bufferMap, createBuffer$1, getDataFunc, state);
	}


	/* VboBufferSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function render(gl, uid, state) {
	  var transformIndex = unsafeGetTransformComponent(uid, state);
	  var materialIndex = unsafeGetMaterialComponent(uid, state);
	  var shaderIndex = unsafeGetShaderIndex(materialIndex, state);
	  var geometryIndex = unsafeGetGeometryComponent(uid, state);
	  var match = getVboBufferData(state);
	  var vertexBufferMap = match[/* vertexBufferMap */0];
	  var elementArrayBufferMap = match[/* elementArrayBufferMap */1];
	  var program = unsafeGetProgram(shaderIndex, state);
	  var state$1 = reduceState((function (state, param) {
	          param[/* sendNoCacheableDataFunc */2](gl, param[/* pos */0], param[/* getNoCacheableDataFunc */1](transformIndex, state));
	          return state;
	        }), state, getUniformSendNoCacheableData(shaderIndex, reduceState((function (state, param) {
	                  var buffer = param[/* buffer */2];
	                  var arrayBuffer;
	                  switch (buffer) {
	                    case "index" : 
	                        arrayBuffer = getOrCreateBuffer$2(gl, geometryIndex, elementArrayBufferMap, unsafeGetIndices$2, state);
	                        break;
	                    case "vertex" : 
	                        arrayBuffer = getOrCreateBuffer$1(gl, geometryIndex, vertexBufferMap, unsafeGetVertices$2, state);
	                        break;
	                    default:
	                      arrayBuffer = throwMessage("unknow buffer:" + (String(buffer) + ""));
	                  }
	                  return param[/* sendFunc */3](gl, param[/* size */1], param[/* pos */0], arrayBuffer, state);
	                }), state, getAttributeSendData(shaderIndex, use(gl, program, state)))));
	  var data = getGLSLSenderData$1(state$1);
	  var lastSendMaterial = data[/* lastSendMaterial */10];
	  var state$2;
	  var exit = 0;
	  if (lastSendMaterial && lastSendMaterial[0] === materialIndex) {
	    state$2 = state$1;
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    data[/* lastSendMaterial */10] = /* Some */[materialIndex];
	    state$2 = reduceState((function (state, param) {
	            param[/* sendCacheableDataFunc */4](gl, param[/* shaderCacheMap */0], param[/* name */1], param[/* pos */2], param[/* getCacheableDataFunc */3](materialIndex, state));
	            return state;
	          }), state$1, getUniformSendCacheableData(shaderIndex, state$1));
	  }
	  return /* tuple */[
	          state$2,
	          shaderIndex,
	          geometryIndex
	        ];
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _setSourceInstance(objectInstance, sourceInstance, data) {
	  set$1(objectInstance, sourceInstance, data[/* sourceInstanceMap */1]);
	  return data;
	}

	function create$11(sourceInstance, uid, state) {
	  var data = getObjectInstanceData(state);
	  var index = data[/* index */0];
	  var disposedIndexArray = data[/* disposedIndexArray */2];
	  var match = generateIndex(index, disposedIndexArray);
	  var index$1 = match[0];
	  data[/* index */0] = match[1];
	  _setSourceInstance(index$1, sourceInstance, data);
	  addComponentToGameObjectMap(index$1, uid, data[/* gameObjectMap */3]);
	  return /* tuple */[
	          state,
	          index$1
	        ];
	}

	var deepCopyStateForRestore$30 = deepCopyStateForRestore$20;


	/* ObjectInstanceStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function markModelMatrixIsStatic$1(sourceInstance, isStatic, state) {
	  set$1(sourceInstance, isStatic, getSourceInstanceData(state)[/* isModelMatrixStaticMap */4]);
	  return state;
	}

	function isModelMatrixIsStatic$2(sourceInstance, state) {
	  return ensureCheck((function () {
	                return test("should exist", (function () {
	                              return assertExist(get$3(sourceInstance, getSourceInstanceData(state)[/* isModelMatrixStaticMap */4]));
	                            }));
	              }), unsafeGet$1(sourceInstance, getSourceInstanceData(state)[/* isModelMatrixStaticMap */4]));
	}

	function markSendModelMatrix$2(sourceInstance, isSend, state) {
	  set$1(sourceInstance, isSend, getSourceInstanceData(state)[/* isSendModelMatrixDataMap */5]);
	  return state;
	}

	function isSendModelMatrix$2(sourceInstance, state) {
	  return ensureCheck((function () {
	                return test("should exist", (function () {
	                              return assertExist(get$3(sourceInstance, getSourceInstanceData(state)[/* isSendModelMatrixDataMap */5]));
	                            }));
	              }), unsafeGet$1(sourceInstance, getSourceInstanceData(state)[/* isSendModelMatrixDataMap */5]));
	}


	/* SourceInstanceStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function create$12(state) {
	  var data = getSourceInstanceData(state);
	  var index = data[/* index */0];
	  var objectInstanceArrayMap = data[/* objectInstanceArrayMap */1];
	  var disposedIndexArray = data[/* disposedIndexArray */6];
	  var match = generateIndex(index, disposedIndexArray);
	  var index$1 = match[0];
	  data[/* index */0] = match[1];
	  set$1(index$1, createEmpty(/* () */0), objectInstanceArrayMap);
	  var state$1 = markSendModelMatrix$2(index$1, /* false */0, markModelMatrixIsStatic$1(index$1, /* true */1, state));
	  return /* tuple */[
	          state$1,
	          index$1
	        ];
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var isAlive$13 = isAlive$9;

	var create$10 = create$12;

	var getObjectInstanceArray$2 = getObjectInstanceArray;

	function _addObjectInstnace(sourceInstance, uid, data) {
	  var objectInstanceArrayMap = data[/* objectInstanceArrayMap */1];
	  unsafeGetObjectInstanceArray(sourceInstance, objectInstanceArrayMap).push(uid);
	  return data;
	}

	function createInstance(sourceInstance, state) {
	  var match = create$9(state);
	  var uid = match[1];
	  var state$1 = match[0];
	  _addObjectInstnace(sourceInstance, uid, getSourceInstanceData(state$1));
	  var match$1 = create$2(state$1);
	  var match$2 = create$11(sourceInstance, uid, match$1[0]);
	  var state$2 = addObjectInstanceComponent$1(uid, match$2[1], addTransformComponent$1(uid, match$1[1], match$2[0]));
	  return /* tuple */[
	          state$2,
	          uid
	        ];
	}

	var getSourceInstanceData$2 = getSourceInstanceData;

	var isSendModelMatrix$1 = isSendModelMatrix$2;

	var markSendModelMatrix$1 = markSendModelMatrix$2;

	var markModelMatrixIsStatic = markModelMatrixIsStatic$1;

	var isModelMatrixIsStatic$1 = isModelMatrixIsStatic$2;

	var deepCopyStateForRestore$29 = deepCopyStateForRestore$18;

	var restore$25 = restore$17;


	/* TransformSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var getSourceInstanceData$1 = getSourceInstanceData$2;

	var getObjectInstanceArray$1 = getObjectInstanceArray$2;

	var isModelMatrixIsStatic = isModelMatrixIsStatic$1;

	var isSendModelMatrix = isSendModelMatrix$1;

	var markSendModelMatrix = markSendModelMatrix$1;

	var deepCopyStateForRestore$28 = deepCopyStateForRestore$29;

	var restore$24 = restore$25;


	/* SourceInstanceSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function render$2(gl, uid, state) {
	  var match = render(gl, uid, state);
	  var state$1 = match[0];
	  var instanceUniformSendNoCacheableData = getInstanceUniformSendNoCacheableData(match[1], state$1);
	  var drawMode = getDrawMode$1(gl);
	  var indexType = getIndexType$1(gl);
	  var indexTypeSize = getIndexTypeSize$1(gl);
	  var indicesCount = getIndicesCount$2(match[2], state$1);
	  var sourceInstance = unsafeGetSourceInstanceComponent(uid, state$1);
	  var objectInstanceArray = getObjectInstanceArray$1(sourceInstance, state$1);
	  return reduceState((function (state, uid) {
	                var state$1 = reduceState((function (state, param) {
	                        param[/* sendNoCacheableDataFunc */2](gl, param[/* pos */0], param[/* getNoCacheableDataFunc */1](unsafeGetTransformComponent(uid, state), state));
	                        return state;
	                      }), state, instanceUniformSendNoCacheableData);
	                drawElement(drawMode, indexType, indexTypeSize, indicesCount, gl);
	                return state$1;
	              }), state$1, objectInstanceArray);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function createBuffer$2(gl, capacity, state) {
	  var buffer = getInstanceBuffer(gl, state);
	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ARRAY_BUFFER, capacity, gl.DYNAMIC_DRAW);
	  return buffer;
	}

	function _getFloat32InstanceArraySize(capacity) {
	  requireCheck((function () {
	          return test("capacity should be a multiplier of 4", (function () {
	                        return Operators[/* = */0](capacity % 4, 0);
	                      }));
	        }));
	  return capacity / 4 | 0;
	}

	function _getCapacity(sourceInstance, capacityMap) {
	  var match = get$3(sourceInstance, capacityMap);
	  if (match) {
	    return match[0];
	  } else {
	    return 4096;
	  }
	}

	function _setCapacity(sourceInstance, capacity, capacityMap) {
	  set$1(sourceInstance, capacity, capacityMap);
	  return capacityMap;
	}

	function getOrCreateBuffer$3(gl, sourceInstance, capacityMap, bufferMap, state) {
	  var match = get$3(sourceInstance, bufferMap);
	  if (match) {
	    return match[0];
	  } else {
	    var buffer = createBuffer$2(gl, _getCapacity(sourceInstance, capacityMap), state);
	    set$1(sourceInstance, buffer, bufferMap);
	    return buffer;
	  }
	}

	function getOrCreateModelMatrixFloat32Array(sourceInstance, capacityMap, modelMatrixFloat32ArrayMap, state) {
	  var capacity = _getCapacity(sourceInstance, capacityMap);
	  var match = get$3(sourceInstance, modelMatrixFloat32ArrayMap);
	  if (match) {
	    return match[0];
	  } else {
	    var match$1 = getFloat32TypeArrayFromPool(capacity, state);
	    if (match$1) {
	      return match$1[0];
	    } else {
	      var typeArr = new Float32Array(_getFloat32InstanceArraySize(capacity));
	      set$1(sourceInstance, typeArr, modelMatrixFloat32ArrayMap);
	      return typeArr;
	    }
	  }
	}

	function setCapacityAndUpdateBufferAndTypeArray(gl, sourceInstance, capacity, buffer, modelMatrixFloat32Array, bufferMap, modelMatrixFloat32ArrayMap, capacityMap, state) {
	  var currentCapacity = _getCapacity(sourceInstance, capacityMap);
	  var needIncreaseCapacity = /* false */0;
	  while(currentCapacity < capacity) {
	    currentCapacity = (currentCapacity << 1);
	    needIncreaseCapacity = /* true */1;
	  }
	  if (needIncreaseCapacity) {
	    _setCapacity(sourceInstance, currentCapacity, capacityMap);
	    gl.deleteBuffer(buffer);
	    var buffer$1 = createBuffer$2(gl, currentCapacity, state);
	    set$1(sourceInstance, buffer$1, bufferMap);
	    var modelMatrixFloat32Array$1 = new Float32Array(_getFloat32InstanceArraySize(currentCapacity));
	    set$1(sourceInstance, modelMatrixFloat32Array$1, modelMatrixFloat32ArrayMap);
	    return /* tuple */[
	            buffer$1,
	            modelMatrixFloat32Array$1
	          ];
	  } else {
	    return /* tuple */[
	            buffer,
	            modelMatrixFloat32Array
	          ];
	  }
	}

	function updateData(gl, data, buffer) {
	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	  gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);
	  return buffer;
	}


	/* TypeArrayPoolSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _fillModelMatrixTypeArr(uid, matricesArrayForInstance, offset, state) {
	  var transform = unsafeGetTransformComponent(uid, state);
	  fillFloat32ArrayWithFloat32Array(matricesArrayForInstance, offset, getLocalToWorldMatrixTypeArray(transform, state), 0, 16);
	  return state;
	}

	function _sendModelMatrixData(gl, sourceUid, extension, sourceInstance, shaderIndex, objectInstanceArray, instanceRenderListCount, modelMatrixInstanceBufferCapacityMap, modelMatrixInstanceBufferMap, modelMatrixFloat32ArrayMap, _, state) {
	  var modelMatrixInstanceBuffer = getOrCreateBuffer$3(gl, sourceInstance, modelMatrixInstanceBufferCapacityMap, modelMatrixInstanceBufferMap, state);
	  var matricesArrayForInstance = getOrCreateModelMatrixFloat32Array(sourceInstance, modelMatrixInstanceBufferCapacityMap, modelMatrixFloat32ArrayMap, state);
	  var match = setCapacityAndUpdateBufferAndTypeArray(gl, sourceInstance, (instanceRenderListCount << 6), modelMatrixInstanceBuffer, matricesArrayForInstance, modelMatrixInstanceBufferMap, modelMatrixFloat32ArrayMap, modelMatrixInstanceBufferCapacityMap, state);
	  var matricesArrayForInstance$1 = match[1];
	  var offset = [0];
	  var state$1 = _fillModelMatrixTypeArr(sourceUid, matricesArrayForInstance$1, offset[0], state);
	  offset[0] = offset[0] + 16 | 0;
	  var state$2 = reduceState((function (state, objectInstance) {
	          var state$1 = _fillModelMatrixTypeArr(objectInstance, matricesArrayForInstance$1, offset[0], state);
	          offset[0] = offset[0] + 16 | 0;
	          return state$1;
	        }), state$1, objectInstanceArray);
	  updateData(gl, matricesArrayForInstance$1, match[0]);
	  forEachi((function (param, index) {
	          var pos = param[/* pos */0];
	          gl.enableVertexAttribArray(pos);
	          gl.vertexAttribPointer(pos, 4, gl.FLOAT, false, 64, (index << 4));
	          return extension.vertexAttribDivisorANGLE(pos, 1);
	        }), getInstanceAttributeSendData(shaderIndex, state$2));
	  return state$2;
	}

	function render$3(gl, uid, state) {
	  var match = render(gl, uid, state);
	  var shaderIndex = match[1];
	  var state$1 = match[0];
	  var extension = getExn(getGpuDetectData(state$1)[/* extensionInstancedArrays */0]);
	  var transformData = getTransformData(state$1);
	  var match$1 = getVboBufferData(state$1);
	  var modelMatrixInstanceBufferMap = match$1[/* modelMatrixInstanceBufferMap */2];
	  var match$2 = getSourceInstanceData$1(state$1);
	  var modelMatrixFloat32ArrayMap = match$2[/* modelMatrixFloat32ArrayMap */3];
	  var modelMatrixInstanceBufferCapacityMap = match$2[/* modelMatrixInstanceBufferCapacityMap */2];
	  var sourceInstance = unsafeGetSourceInstanceComponent(uid, state$1);
	  var objectInstanceArray = getObjectInstanceArray$1(sourceInstance, state$1);
	  var instanceRenderListCount = objectInstanceArray.length + 1 | 0;
	  var match$3 = isModelMatrixIsStatic(sourceInstance, state$1);
	  var state$2;
	  if (match$3 !== 0) {
	    var match$4 = isSendModelMatrix(sourceInstance, state$1);
	    state$2 = match$4 !== 0 ? state$1 : markSendModelMatrix(sourceInstance, /* true */1, _sendModelMatrixData(gl, uid, extension, sourceInstance, shaderIndex, objectInstanceArray, instanceRenderListCount, modelMatrixInstanceBufferCapacityMap, modelMatrixInstanceBufferMap, modelMatrixFloat32ArrayMap, transformData, state$1));
	  } else {
	    state$2 = _sendModelMatrixData(gl, uid, extension, sourceInstance, shaderIndex, objectInstanceArray, instanceRenderListCount, modelMatrixInstanceBufferCapacityMap, modelMatrixInstanceBufferMap, modelMatrixFloat32ArrayMap, transformData, markSendModelMatrix(sourceInstance, /* false */0, state$1));
	  }
	  drawElementsInstancedANGLE(getDrawMode$1(gl), getIndexType$1(gl), getIndexTypeSize$1(gl), getIndicesCount$2(match[2], state$2), instanceRenderListCount, extension);
	  return state$2;
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function render$1(gl, uid, state) {
	  if (isSupportInstance(state)) {
	    return render$3(gl, uid, state);
	  } else {
	    return render$2(gl, uid, state);
	  }
	}


	/* InstanceUtils-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _sendShaderUniformData(gl, state) {
	  return reduceState((function (state, shaderIndex) {
	                var program = unsafeGetProgram(shaderIndex, state);
	                return reduceState((function (state, param) {
	                              param[/* sendNoCacheableDataFunc */2](gl, param[/* pos */0], param[/* getNoCacheableDataFunc */1](state));
	                              return state;
	                            }), state, getShaderUniformSendNoCacheableData(shaderIndex, use(gl, program, state)));
	              }), state, getAllShaderIndexArray(state));
	}

	function _render(gl, state) {
	  var state$1 = _sendShaderUniformData(gl, state);
	  var match = getRenderArrayFromState(state$1);
	  if (match) {
	    return reduceState((function (state, uid) {
	                  if (isSourceInstance(uid, state)) {
	                    return render$1(gl, uid, state);
	                  } else {
	                    var match = render(gl, uid, state);
	                    var state$1 = match[0];
	                    drawElement(getDrawMode$1(gl), getIndexType$1(gl), getIndexTypeSize$1(gl), getIndicesCount$2(match[2], state$1), gl);
	                    return state$1;
	                  }
	                }), state$1, match[0]);
	  } else {
	    return state$1;
	  }
	}

	function getJob$2(_, gl, state) {
	  return _render(gl, state);
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var getGameObject$9 = getGameObject$7;

	var getCurrentCameraController$1 = getCurrentCameraController;

	var getWorldToCameraMatrix$1 = getWorldToCameraMatrix;

	var getPMatrix$1 = getPMatrix;

	var deepCopyStateForRestore$31 = deepCopyStateForRestore$24;


	/* CameraControllerSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getTransformFromCameraController(cameraController, state) {
	  var match = getGameObject$9(cameraController, state);
	  if (match) {
	    return unsafeGetTransformComponent(match[0], state);
	  } else {
	    return throwMessage("cameraController's gameObject should exist");
	  }
	}


	/* GameObjectAdmin-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _getCameraData$1(state) {
	  var match = getCurrentCameraController$1(state);
	  if (match) {
	    var currentCameraController = match[0];
	    var transform = getTransformFromCameraController(currentCameraController, state);
	    return /* Some */[/* record */[
	              /* vMatrix */getWorldToCameraMatrix$1(transform, state),
	              /* pMatrix */getPMatrix$1(currentCameraController, state)
	            ]];
	  } else {
	    return /* None */0;
	  }
	}

	function getJob$3(_, _$1, state) {
	  setCameraData(_getCameraData$1(state), state);
	  return state;
	}


	/* GetComponentUtils-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getRenderArray$1(state) {
	  return getMeshRendererData(state)[/* renderGameObjectArray */1];
	}

	function getGameObject$10(meshRenderer, state) {
	  var match = getMeshRendererData(state);
	  return getComponentGameObject(meshRenderer, match[/* gameObjectMap */2]);
	}

	var isAlive$15 = isAlive$7;

	var create$13 = create$6;

	var deepCopyStateForRestore$33 = deepCopyStateForRestore$17;


	/* MeshRendererStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var getRenderArray = getRenderArray$1;

	var deepCopyStateForRestore$32 = deepCopyStateForRestore$33;


	/* MeshRendererSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getJob$4(_, _$1, state) {
	  setRenderArray(getRenderArray(state), state);
	  return state;
	}


	/* MeshRendererAdmin-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getJob$5(_, gl, state) {
	  return pregetGLSLData(gl, state);
	}


	/* MaterialAdmin-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var create$14 = create$4;

	function init$7(gl, state) {
	  requireCheck((function () {
	          return test("shouldn't dispose any material before init", (function () {
	                        return assertTrue(isNotDisposed$1(getMaterialData(state)));
	                      }));
	        }));
	  return reduceState((function (state, materialIndex) {
	                return initMaterial(gl, materialIndex, state);
	              }), state, range(0, getMaterialData(state)[/* index */0] - 1 | 0));
	}


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var initBasicMaterial = init$7;


	/* BasicMaterialSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getJob$6(_, gl, state) {
	  return initBasicMaterial(gl, state);
	}


	/* BasicMaterialAdmin-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _getRenderJobHandles() {
	  return /* :: */[
	          /* tuple */[
	            "get_render_array",
	            getJob$4
	          ],
	          /* :: */[
	            /* tuple */[
	              "get_camera_data",
	              getJob$3
	            ],
	            /* :: */[
	              /* tuple */[
	                "clear_color",
	                getJob
	              ],
	              /* :: */[
	                /* tuple */[
	                  "clear_buffer",
	                  getJob$1
	                ],
	                /* :: */[
	                  /* tuple */[
	                    "render_basic",
	                    getJob$2
	                  ],
	                  /* [] */0
	                ]
	              ]
	            ]
	          ]
	        ];
	}

	function createJobHandleMap() {
	  return fromList(concat$1(/* :: */[
	                  /* :: */[
	                    /* tuple */[
	                      "preget_glslData",
	                      getJob$5
	                    ],
	                    /* :: */[
	                      /* tuple */[
	                        "init_basic_material",
	                        getJob$6
	                      ],
	                      /* [] */0
	                    ]
	                  ],
	                  /* :: */[
	                    _getRenderJobHandles(/* () */0),
	                    /* [] */0
	                  ]
	                ]));
	}


	/* ClearColorJob-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$8() {
	  return /* record */[
	          /* vertexBufferMap */createEmpty$2(/* () */0),
	          /* elementArrayBufferMap */createEmpty$2(/* () */0),
	          /* modelMatrixInstanceBufferMap */createEmpty$2(/* () */0),
	          /* vertexArrayBufferPool */createEmpty(/* () */0),
	          /* elementArrayBufferPool */createEmpty(/* () */0),
	          /* modelMatrixInstanceBufferPool */createEmpty(/* () */0)
	        ];
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$9() {
	  return /* record */[
	          /* attributeSendDataMap */createEmpty$2(/* () */0),
	          /* instanceAttributeSendDataMap */createEmpty$2(/* () */0),
	          /* uniformCacheMap */createEmpty$2(/* () */0),
	          /* uniformSendNoCacheableDataMap */createEmpty$2(/* () */0),
	          /* uniformSendCacheableDataMap */createEmpty$2(/* () */0),
	          /* shaderUniformSendNoCacheableDataMap */createEmpty$2(/* () */0),
	          /* instanceUniformSendNoCacheableDataMap */createEmpty$2(/* () */0),
	          /* vertexAttribHistoryArray */createEmpty(/* () */0),
	          /* lastSendArrayBuffer : None */0,
	          /* lastSendElementArrayBuffer : None */0,
	          /* lastSendMaterial : None */0
	        ];
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$10() {
	  return /* record */[
	          /* uid */0,
	          /* disposeCount */0,
	          /* disposedUidMap */createEmpty$2(/* () */0),
	          /* aliveUidArray */createEmpty(/* () */0),
	          /* transformMap */createEmpty$2(/* () */0),
	          /* cameraControllerMap */createEmpty$2(/* () */0),
	          /* geometryMap */createEmpty$2(/* () */0),
	          /* meshRendererMap */createEmpty$2(/* () */0),
	          /* materialMap */createEmpty$2(/* () */0),
	          /* sourceInstanceMap */createEmpty$2(/* () */0),
	          /* objectInstanceMap */createEmpty$2(/* () */0)
	        ];
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$11() {
	  return /* record */[/* float32Array1 */new Float32Array(/* float array */[
	                1,
	                0,
	                0,
	                0,
	                0,
	                1,
	                0,
	                0,
	                0,
	                0,
	                1,
	                0,
	                0,
	                0,
	                0,
	                1
	              ])];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$12() {
	  return /* record */[
	          /* renderArray : None */0,
	          /* cameraData : None */0
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var render_pipelines = "\n[\n  {\"name\": \"simple_basic_render\", \"jobs\":[\n    {\"name\": \"get_render_array\"},\n    {\"name\": \"get_camera_data\"},\n    {\"name\": \"clear_color\", \"flags\": [\"#000000\"]},\n    {\"name\": \"clear_buffer\", \"flags\": [\"COLOR_BUFFER\", \"DEPTH_BUFFER\", \"STENCIL_BUFFER\"]},\n    {\"name\": \"render_basic\"}\n  ]}\n]\n";


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$13() {
	  return /* record */[
	          /* attributeLocationMap */createEmpty$2(/* () */0),
	          /* uniformLocationMap */createEmpty$2(/* () */0)
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$14() {
	  return /* record */[
	          /* index */0,
	          /* renderGameObjectArray */createEmpty(/* () */0),
	          /* gameObjectMap */createEmpty$2(/* () */0),
	          /* disposedIndexArray */createEmpty(/* () */0)
	        ];
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var deepCopyStateForRestore$34 = deepCopyStateForRestore$30;


	/* ObjectInstanceSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$15() {
	  return /* record */[
	          /* float32ArrayPoolMap */createEmpty$2(/* () */0),
	          /* uint16ArrayPoolMap */createEmpty$2(/* () */0)
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$16() {
	  return /* record */[
	          /* index */0,
	          /* sourceInstanceMap */createEmpty$2(/* () */0),
	          /* disposedIndexArray */createEmpty(/* () */0),
	          /* gameObjectMap */createEmpty$2(/* () */0)
	        ];
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$17() {
	  return /* record */[
	          /* index */0,
	          /* objectInstanceArrayMap */createEmpty$2(/* () */0),
	          /* modelMatrixInstanceBufferCapacityMap */createEmpty$2(/* () */0),
	          /* modelMatrixFloat32ArrayMap */createEmpty$2(/* () */0),
	          /* isModelMatrixStaticMap */createEmpty$2(/* () */0),
	          /* isSendModelMatrixDataMap */createEmpty$2(/* () */0),
	          /* disposedIndexArray */createEmpty(/* () */0),
	          /* gameObjectMap */createEmpty$2(/* () */0)
	        ];
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$18() {
	  return /* record */[
	          /* elapsed */0,
	          /* startTime */0,
	          /* deltaTime */0,
	          /* lastTime : None */0,
	          /* gameTime */0,
	          /* fps */0
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$20() {
	  return /* record */[
	          /* nearMap */createEmpty$2(/* () */0),
	          /* farMap */createEmpty$2(/* () */0),
	          /* fovyMap */createEmpty$2(/* () */0),
	          /* aspectMap */createEmpty$2(/* () */0)
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$19() {
	  return /* record */[
	          /* index */0,
	          /* cameraArray */createEmpty(/* () */0),
	          /* dirtyArray */createEmpty(/* () */0),
	          /* pMatrixMap */createEmpty$2(/* () */0),
	          /* gameObjectMap */createEmpty$2(/* () */0),
	          /* updateCameraFuncMap */createEmpty$2(/* () */0),
	          /* perspectiveCameraData */initData$20(/* () */0),
	          /* disposedIndexArray */createEmpty(/* () */0)
	        ];
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	var Bottom = create$1("Array.Bottom");


	/* No side effect */

	var DecodeError = create$1("Json_decode.DecodeError");

	function string(json) {
	  if (typeof json === "string") {
	    return json;
	  } else {
	    throw [
	          DecodeError,
	          "Expected string, got " + JSON.stringify(json)
	        ];
	  }
	}

	function array(decode, json) {
	  if (Array.isArray(json)) {
	    var length = json.length;
	    var target = new Array(length);
	    for(var i = 0 ,i_finish = length - 1 | 0; i <= i_finish; ++i){
	      var value = _1(decode, json[i]);
	      target[i] = value;
	    }
	    return target;
	  } else {
	    throw [
	          DecodeError,
	          "Expected array, got " + JSON.stringify(json)
	        ];
	  }
	}

	function field(key, decode, json) {
	  if (typeof json === "object" && !Array.isArray(json) && json !== null) {
	    var match = json[key];
	    if (match !== undefined) {
	      return _1(decode, match);
	    } else {
	      throw [
	            DecodeError,
	            "Expected field \'" + (String(key) + "\'")
	          ];
	    }
	  } else {
	    throw [
	          DecodeError,
	          "Expected object, got " + JSON.stringify(json)
	        ];
	  }
	}

	function optional(decode, json) {
	  var exit = 0;
	  var v;
	  try {
	    v = _1(decode, json);
	    exit = 1;
	  }
	  catch (raw_exn){
	    var exn = internalToOCamlException(raw_exn);
	    if (exn[0] === DecodeError) {
	      return /* None */0;
	    } else {
	      throw exn;
	    }
	  }
	  if (exit === 1) {
	    return /* Some */[v];
	  }
	  
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function convertRenderSettingToRecord(render_setting) {
	  var json = JSON.parse(render_setting);
	  return /* record */[
	          /* platform */field("platform", string, json),
	          /* backend */field("backend", (function (json) {
	                  return /* record */[
	                          /* name */field("name", string, json),
	                          /* fail */optional((function (param) {
	                                  return field("fail", string, param);
	                                }), json)
	                        ];
	                }), json),
	          /* browser */field("browser", (function (json) {
	                  return array((function (json) {
	                                return /* record */[
	                                        /* name */field("name", string, json),
	                                        /* version */field("version", string, json)
	                                      ];
	                              }), json);
	                }), json),
	          /* init_pipeline */field("init_pipeline", string, json),
	          /* render_pipeline */field("render_pipeline", string, json)
	        ];
	}

	function _convertPipelinesToRecord(pipelines) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* jobs */field("jobs", (function (param) {
	                                return array((function (json) {
	                                              return /* record */[
	                                                      /* name */field("name", string, json),
	                                                      /* flags */optional((function (param) {
	                                                              return field("flags", (function (json) {
	                                                                            return array(string, json);
	                                                                          }), param);
	                                                            }), json)
	                                                    ];
	                                            }), param);
	                              }), json)
	                      ];
	              }), JSON.parse(pipelines));
	}

	function _convertJobsToRecord(jobs) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* shader */optional((function (param) {
	                                return field("shader", string, param);
	                              }), json)
	                      ];
	              }), JSON.parse(jobs));
	}

	var convertInitPipelinesToRecord = _convertPipelinesToRecord;

	var convertInitJobsToRecord = _convertJobsToRecord;

	var convertRenderPipelinesToRecord = _convertPipelinesToRecord;

	var convertRenderJobsToRecord = _convertJobsToRecord;

	function convertShadersToRecord(shaders) {
	  var json = JSON.parse(shaders);
	  return /* record */[
	          /* static_branchs */field("static_branchs", (function (json) {
	                  return array((function (json) {
	                                return /* record */[
	                                        /* name */field("name", string, json),
	                                        /* value */field("value", (function (param) {
	                                                return array(string, param);
	                                              }), json)
	                                      ];
	                              }), json);
	                }), json),
	          /* groups */field("groups", (function (json) {
	                  return array((function (json) {
	                                return /* record */[
	                                        /* name */field("name", string, json),
	                                        /* value */field("value", (function (param) {
	                                                return array(string, param);
	                                              }), json)
	                                      ];
	                              }), json);
	                }), json),
	          /* basic_material */field("basic_material", (function (json) {
	                  return /* record */[/* material_shader */field("material_shader", (function (json) {
	                                  return /* record */[/* shader_libs */field("shader_libs", (function (param) {
	                                                  return array((function (json) {
	                                                                return /* record */[
	                                                                        /* type_ */optional((function (param) {
	                                                                                return field("type", string, param);
	                                                                              }), json),
	                                                                        /* name */field("name", string, json)
	                                                                      ];
	                                                              }), param);
	                                                }), json)];
	                                }), json)];
	                }), json)
	        ];
	}

	function convertShaderLibsToRecord(shader_libs) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* glsls */optional((function (param) {
	                                return field("glsls", (function (json) {
	                                              return array((function (json) {
	                                                            return /* record */[
	                                                                    /* type_ */field("type", string, json),
	                                                                    /* name */field("name", string, json)
	                                                                  ];
	                                                          }), json);
	                                            }), param);
	                              }), json),
	                        /* variables */optional((function (param) {
	                                return field("variables", (function (json) {
	                                              return /* record */[
	                                                      /* uniforms */optional((function (param) {
	                                                              return field("uniforms", (function (json) {
	                                                                            return array((function (json) {
	                                                                                          return /* record */[
	                                                                                                  /* name */field("name", string, json),
	                                                                                                  /* field */field("field", string, json),
	                                                                                                  /* type_ */field("type", string, json),
	                                                                                                  /* from */field("from", string, json)
	                                                                                                ];
	                                                                                        }), json);
	                                                                          }), param);
	                                                            }), json),
	                                                      /* attributes */optional((function (param) {
	                                                              return field("attributes", (function (json) {
	                                                                            return array((function (json) {
	                                                                                          return /* record */[
	                                                                                                  /* name */optional((function (param) {
	                                                                                                          return field("name", string, param);
	                                                                                                        }), json),
	                                                                                                  /* buffer */field("buffer", string, json),
	                                                                                                  /* type_ */optional((function (param) {
	                                                                                                          return field("type", string, param);
	                                                                                                        }), json)
	                                                                                                ];
	                                                                                        }), json);
	                                                                          }), param);
	                                                            }), json)
	                                                    ];
	                                            }), param);
	                              }), json)
	                      ];
	              }), JSON.parse(shader_libs));
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function initData$21() {
	  return /* record */[
	          /* count */0,
	          /* funcRecordArray */createEmpty(/* () */0),
	          /* isFinishMap */createEmpty$2(/* () */0)
	        ];
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getSchedulerData(state) {
	  return state[/* schedulerData */22];
	}

	function deepCopyStateForRestore$36(state) {
	  var match = state[/* schedulerData */22];
	  var count = match[/* count */0];
	  var newrecord = state.slice();
	  newrecord[/* schedulerData */22] = /* record */[
	    /* count */count,
	    /* funcRecordArray */match[/* funcRecordArray */1].slice(),
	    /* isFinishMap */copy$1(match[/* isFinishMap */2])
	  ];
	  return newrecord;
	}


	/* SparseMapSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function update$5(taskFunc, elapsed, state) {
	  return taskFunc(elapsed, state);
	}

	function isFinish(index, state) {
	  var match = getSchedulerData(state);
	  var match$1 = get$3(index, match[/* isFinishMap */2]);
	  if (match$1) {
	    return match$1[0];
	  } else {
	    return /* false */0;
	  }
	}

	function start$1(state) {
	  return state;
	}


	/* ScheduleStateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _remove(index, state) {
	  var data = getSchedulerData(state);
	  var count = data[/* count */0];
	  deleteBySwap(index, count - 1 | 0, data[/* funcRecordArray */1]);
	  data[/* count */0] = data[/* count */0] - 1 | 0;
	  return state;
	}

	function _getFuncRecord(index, funcRecordArray) {
	  requireCheck((function () {
	          return test("" + (String(funcRecordArray) + ("[" + (String(index) + "] should exist"))), (function () {
	                        return assertExist(get$1(index, funcRecordArray));
	                      }));
	        }));
	  return funcRecordArray[index];
	}

	function update$4(elapsed, state) {
	  var match = getSchedulerData(state);
	  var count = match[/* count */0];
	  var funcRecordArray = match[/* funcRecordArray */1];
	  return reduceState((function (state, index) {
	                var match = _getFuncRecord(index, funcRecordArray);
	                var state$1 = _2(match[/* update */0], elapsed, state);
	                if (_1(match[/* isFinish */1], state$1)) {
	                  return _remove(index, state$1);
	                } else {
	                  return state$1;
	                }
	              }), state, range(0, count - 1 | 0));
	}

	function start(state) {
	  var data = getSchedulerData(state);
	  var count = data[/* count */0];
	  var funcRecordArray = data[/* funcRecordArray */1];
	  return reduceState((function (state, index) {
	                var match = _getFuncRecord(index, funcRecordArray);
	                return _1(match[/* start */2], state);
	              }), state, range(0, count - 1 | 0));
	}

	function scheduleLoop$1(taskFunc, state) {
	  var data = getSchedulerData(state);
	  var index = data[/* count */0];
	  data[/* funcRecordArray */1][index] = /* record */[
	    /* update */(function (param, param$1) {
	        return update$5(taskFunc, param, param$1);
	      }),
	    /* isFinish */(function (param) {
	        return isFinish(index, param);
	      }),
	    /* start */start$1
	  ];
	  data[/* count */0] = data[/* count */0] + 1 | 0;
	  return state;
	}

	var deepCopyStateForRestore$35 = deepCopyStateForRestore$36;


	/* ArraySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getState$1(stateData) {
	  return getExn(stateData[/* state */0]);
	}

	function setState$1(stateData, state) {
	  stateData[/* state */0] = /* Some */[state];
	  return state;
	}

	function deepCopyStateForRestore$25(state) {
	  return deepCopyStateForRestore$35(deepCopyStateForRestore$1(deepCopyStateForRestore$34(deepCopyStateForRestore$28(deepCopyStateForRestore$9(deepCopyStateForRestore$23(deepCopyStateForRestore$11(deepCopyStateForRestore$4(deepCopyStateForRestore$3(deepCopyStateForRestore$2(deepCopyStateForRestore$27(deepCopyStateForRestore$15(deepCopyStateForRestore$26(deepCopyStateForRestore$31(deepCopyStateForRestore$6(deepCopyStateForRestore$32(state))))))))))))))));
	}

	function _getSharedData(currentState) {
	  return /* record */[
	          /* gl */getGl(currentState),
	          /* float32ArrayPoolMap */getFloat32ArrayPoolMap(currentState),
	          /* uint16ArrayPoolMap */getUint16ArrayPoolMap(currentState)
	        ];
	}

	function restore$21(stateData, currentState, targetState) {
	  var intersectShaderIndexDataArray = getIntersectShaderIndexDataArray(currentState, targetState);
	  var sharedData = _getSharedData(currentState);
	  var match = restore$22(currentState, sharedData, targetState);
	  var match$1 = restore$4(currentState, match[1], match[0]);
	  var match$2 = restore$24(currentState, match$1[1], match$1[0]);
	  var sharedData$1 = match$2[1];
	  var targetState$1 = restore$20(currentState, sharedData$1, match$2[0]);
	  var gl = getGl(targetState$1);
	  return setState$1(stateData, restore$8(currentState, restore$11(currentState, restore(gl, currentState, restore$23(intersectShaderIndexDataArray, currentState, restore$12(intersectShaderIndexDataArray, currentState, restore$2(intersectShaderIndexDataArray, currentState, restore$1(currentState, restore$15(currentState, restore$7(currentState, sharedData$1, targetState$1))))))))));
	}

	function createState($staropt$star, _) {
	  var renderConfig = $staropt$star ? $staropt$star[0] : /* tuple */[
	      render_setting,
	      init_pipelines,
	      render_pipelines,
	      init_jobs,
	      render_jobs,
	      shaders,
	      shader_libs
	    ];
	  return /* record */[
	          /* bufferConfig : None */0,
	          /* gpuConfig : None */0,
	          /* memoryConfig */initData(/* () */0),
	          /* renderConfig : record */[
	            /* jobHandleMap */createJobHandleMap(/* () */0),
	            /* render_setting */convertRenderSettingToRecord(renderConfig[0]),
	            /* init_pipelines */convertInitPipelinesToRecord(renderConfig[1]),
	            /* render_pipelines */convertRenderPipelinesToRecord(renderConfig[2]),
	            /* init_jobs */convertInitJobsToRecord(renderConfig[3]),
	            /* render_jobs */convertRenderJobsToRecord(renderConfig[4]),
	            /* shaders */convertShadersToRecord(renderConfig[5]),
	            /* shader_libs */convertShaderLibsToRecord(renderConfig[6])
	          ],
	          /* gpuDetectData : record */[
	            /* extensionInstancedArrays : None */0,
	            /* precision : None */0
	          ],
	          /* sourceInstanceData */initData$17(/* () */0),
	          /* objectInstanceData */initData$16(/* () */0),
	          /* viewData : record */[
	            /* canvas : None */0,
	            /* contextConfig : None */0
	          ],
	          /* initConfig : record */[/* isTest : false */0],
	          /* deviceManagerData : record */[
	            /* gl : None */0,
	            /* colorWrite : None */0,
	            /* clearColor : None */0
	          ],
	          /* gameObjectData */initData$10(/* () */0),
	          /* transformData : None */0,
	          /* cameraControllerData */initData$19(/* () */0),
	          /* materialData : None */0,
	          /* geometryData : None */0,
	          /* meshRendererData */initData$14(/* () */0),
	          /* shaderData */initData$6(/* () */0),
	          /* programData */initData$7(/* () */0),
	          /* glslLocationData */initData$13(/* () */0),
	          /* glslSenderData */initData$9(/* () */0),
	          /* glslChunkData */initData$2(/* () */0),
	          /* renderData */initData$12(/* () */0),
	          /* schedulerData */initData$21(/* () */0),
	          /* timeControllerData */initData$18(/* () */0),
	          /* vboBufferData */initData$8(/* () */0),
	          /* globalTempData */initData$11(/* () */0),
	          /* typeArrayPoolData */initData$15(/* () */0)
	        ];
	}


	/* ShaderHelper-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function setMainConfig$1(config) {
	  return init(setConfig(config, createState(/* None */0, /* () */0)));
	}


	/* MainSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function restoreState$1(currentState, targetState) {
	  return restore$21(stateData, currentState, targetState);
	}

	function getStateData$1() {
	  return stateData;
	}

	function getState$2() {
	  return getState$1(stateData);
	}

	function setState$2(state) {
	  return setState$1(stateData, state);
	}

	var deepCopyStateForRestore$37 = deepCopyStateForRestore$25;


	/* StateSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function filterHardwareRelatedSetting(param) {
	  return /* record */[
	          /* platform */param[/* platform */0],
	          /* backend */param[/* backend */1],
	          /* browser */param[/* browser */2]
	        ];
	}

	function init$10(state) {
	  filterHardwareRelatedSetting(getRenderSetting(state));
	  return execJobs(getGl(state), getInitPipelineExecutableJobs(getRenderSetting(state), getInitPipelines(state), getInitJobs(state)), state);
	}

	function render$4(state) {
	  return execJobs(getGl(state), getRenderPipelineExecutableJobs(getRenderSetting(state), getRenderPipelines(state), getRenderJobs(state)), state);
	}


	/* RenderConfigSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGameTime$1(state) {
	  return state[/* timeControllerData */23][/* gameTime */4];
	}

	function getFps$1(state) {
	  return state[/* timeControllerData */23][/* fps */5];
	}

	function _computeFps(deltaTime, lastTime) {
	  if (lastTime) {
	    return 1000 / deltaTime;
	  } else {
	    return 60;
	  }
	}

	function tick(elapsed, state) {
	  var data = state[/* timeControllerData */23];
	  var lastTime = data[/* lastTime */3];
	  var deltaTime = lastTime ? elapsed - lastTime[0] : elapsed;
	  data[/* deltaTime */2] = deltaTime;
	  data[/* fps */5] = _computeFps(deltaTime, lastTime);
	  data[/* gameTime */4] = elapsed / 1000;
	  data[/* lastTime */3] = /* Some */[elapsed];
	  return state;
	}

	function start$3(state) {
	  var data = state[/* timeControllerData */23];
	  data[/* startTime */1] = window.performance.now();
	  data[/* elapsed */0] = 0;
	  return state;
	}

	function computeElapseTime(time, state) {
	  var data = state[/* timeControllerData */23];
	  var startTime = data[/* startTime */1];
	  data[/* elapsed */0] = leastFloat(0, time - startTime);
	  return ensureCheck((function (r) {
	                return test("elapsed should >= 0, but actual is " + (String(r) + ""), (function () {
	                              return Operators[/* >=. */8](r, 0);
	                            }));
	              }), data[/* elapsed */0]);
	}


	/* NumberUtils-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function init$9(state) {
	  return start(start$3(init$10(init$1(state))));
	}

	function _sync(time, state) {
	  var elapsed = computeElapseTime(time, state);
	  return update(elapsed, update$4(elapsed, tick(elapsed, state)));
	}

	function loopBody$2(time, state) {
	  return render$4(_sync(time, state));
	}

	function start$2(state) {
	  var _loop = function (_, state) {
	    return requestAnimationFrame((function (time) {
	                  _loop(time, setState$1(stateData, render$4(_sync(time, state))));
	                  return /* () */0;
	                }));
	  };
	  _loop(0, init$9(state));
	  return /* () */0;
	}


	/* StateSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var startDirector$1 = start$2;

	var initDirector$1 = init$9;

	var loopBody$1 = loopBody$2;


	/* DirectorSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getGeometryDrawMode$1(state) {
	  return getDrawMode(getGl(state));
	}

	function getGeometryVertices$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(geometry, isAlive$11, state);
	        }));
	  return unsafeGetVertices(geometry, state);
	}

	function setGeometryVertices$1(geometry, data, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(geometry, isAlive$11, state);
	        }));
	  return setVertices(geometry, data, state);
	}

	function getGeometryIndices$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(geometry, isAlive$11, state);
	        }));
	  return unsafeGetIndices(geometry, state);
	}

	function setGeometryIndices$1(geometry, data, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(geometry, isAlive$11, state);
	        }));
	  return setIndices(geometry, data, state);
	}

	function getGeometryConfigData$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(geometry, isAlive$11, state);
	        }));
	  return getExn(getConfigData(geometry, state));
	}

	function getGeometryGameObject$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(geometry, isAlive$11, state);
	        }));
	  return getExn(getGameObject$6(geometry, state));
	}


	/* GeometrySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getMaterialGameObject$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(material, isAlive$4, state);
	        }));
	  return getExn(getGameObject$2(material, state));
	}

	function getMaterialColor$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(material, isAlive$4, state);
	        }));
	  return unsafeGetColor$2(material, state);
	}

	function setMaterialColor$1(material, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(material, isAlive$4, state);
	        }));
	  return setColor$1(material, color, state);
	}


	/* MaterialSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var scheduleLoop$2 = scheduleLoop$1;


	/* ScheduleControllerSystem-Wonderjs Not a pure module */

	function iter$4(x, f) {
	  if (x == null) {
	    return /* () */0;
	  } else {
	    return f(x);
	  }
	}

	function from_opt(x) {
	  if (x) {
	    return x[0];
	  } else {
	    return undefined;
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getTransformGameObject$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(transform, isAlive$1, state);
	        }));
	  return getExn(getGameObject(transform, state));
	}

	function getTransformParent$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(transform, isAlive$1, state);
	        }));
	  return from_opt(getParent(transform, state));
	}

	function setTransformParent$1(parent, child, state) {
	  requireCheck((function () {
	          iter$4(parent, (function (parent) {
	                  return checkComponentShouldAlive(parent, isAlive$1, state);
	                }));
	          return checkComponentShouldAlive(child, isAlive$1, state);
	        }));
	  return setParent(parent, child, state);
	}

	function getTransformChildren$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(transform, isAlive$1, state);
	        }));
	  return getChildren(transform, state);
	}

	function getTransformLocalPosition$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(transform, isAlive$1, state);
	        }));
	  return getLocalPositionTuple(transform, state);
	}

	function setTransformLocalPosition$1(transform, localPosition, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(transform, isAlive$1, state);
	        }));
	  return setLocalPositionByTuple(transform, localPosition, state);
	}

	function getTransformPosition$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(transform, isAlive$1, state);
	        }));
	  return getPositionTuple(transform, state);
	}

	function setTransformPosition$1(transform, position, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(transform, isAlive$1, state);
	        }));
	  return setPositionByTuple(transform, position, state);
	}

	var createTransform$1 = create$2;


	/* TransformSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var createGameObject$1 = create;

	function _checkGameObjectShouldAlive(gameObject, state) {
	  return test("gameObject should alive", (function () {
	                return assertTrue(isAlive(gameObject, state));
	              }));
	}

	function addGameObjectTransformComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return addTransformComponent(gameObject, component, state);
	}

	function disposeGameObjectTransformComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return disposeTransformComponent(gameObject, component, state);
	}

	function getGameObjectTransformComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return getExn(getTransformComponent(gameObject, state));
	}

	function hasGameObjectTransformComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return hasTransformComponent(gameObject, state);
	}

	function addGameObjectCameraControllerComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return addCameraControllerComponent(gameObject, component, state);
	}

	function disposeGameObjectCameraControllerComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return disposeCameraControllerComponent(gameObject, component, state);
	}

	function getGameObjectCameraControllerComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return getExn(getCameraControllerComponent(gameObject, state));
	}

	function hasGameObjectCameraControllerComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return hasCameraControllerComponent(gameObject, state);
	}

	function addGameObjectMaterialComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return addMaterialComponent(gameObject, component, state);
	}

	function disposeGameObjectMaterialComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return disposeMaterialComponent(gameObject, component, state);
	}

	function getGameObjectMaterialComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return getExn(getMaterialComponent(gameObject, state));
	}

	function hasGameObjectMaterialComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return hasMaterialComponent(gameObject, state);
	}

	function addGameObjectMeshRendererComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return addMeshRendererComponent(gameObject, component, state);
	}

	function disposeGameObjectMeshRendererComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return disposeMeshRendererComponent(gameObject, component, state);
	}

	function getGameObjectMeshRendererComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return getExn(getMeshRendererComponent(gameObject, state));
	}

	function hasGameObjectMeshRendererComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return hasMeshRendererComponent(gameObject, state);
	}

	function addGameObjectGeometryComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return addGeometryComponent(gameObject, component, state);
	}

	function disposeGameObjectGeometryComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return disposeGeometryComponent(gameObject, component, state);
	}

	function getGameObjectGeometryComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return getExn(getGeometryComponent(gameObject, state));
	}

	function hasGameObjectGeometryComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return hasGeometryComponent(gameObject, state);
	}

	function addGameObjectSourceInstanceComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return addSourceInstanceComponent(gameObject, component, state);
	}

	function getGameObjectSourceInstanceComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return getSourceInstanceComponent(gameObject, state);
	}

	function hasGameObjectSourceInstanceComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return hasSourceInstanceComponent(gameObject, state);
	}

	function disposeGameObjectSourceInstanceComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return disposeSourceInstanceComponent(gameObject, component, batchDispose, state);
	}

	function addGameObjectObjectInstanceComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return addObjectInstanceComponent(gameObject, component, state);
	}

	function getGameObjectObjectInstanceComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return getObjectInstanceComponent(gameObject, state);
	}

	function disposeGameObjectObjectInstanceComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return disposeObjectInstanceComponent(gameObject, component, state);
	}

	var isGameObjectAlive$1 = isAlive;

	function disposeGameObject$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return dispose(gameObject, state);
	}

	function initGameObject$2(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }));
	  return initGameObject$1(gameObject, state);
	}

	function batchDisposeGameObject$1(gameObjectArray, state) {
	  requireCheck((function () {
	          return forEach((function (gameObject) {
	                        return _checkGameObjectShouldAlive(gameObject, state);
	                      }), gameObjectArray);
	        }));
	  return batchDispose(gameObjectArray, state);
	}

	function cloneGameObject$1(gameObject, count, isShareMaterial, state) {
	  return clone(gameObject, count, +isShareMaterial, state);
	}


	/* GameObjectAdmin-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function create$17(state) {
	  var data = getGeometryData(state);
	  var index = data[/* index */0];
	  var disposedIndexArray = data[/* disposedIndexArray */6];
	  var match = generateIndex(index, disposedIndexArray);
	  data[/* index */0] = match[1];
	  return /* tuple */[
	          state,
	          match[0]
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function _computeData(index, state) {
	  var match = getConfigData$1(index, state);
	  if (match) {
	    var configDataMap = match[0];
	    var width = unsafeGet("width", configDataMap);
	    var height = unsafeGet("height", configDataMap);
	    var depth = unsafeGet("depth", configDataMap);
	    var widthSegment = unsafeGet("widthSegment", configDataMap);
	    var heightSegment = unsafeGet("heightSegment", configDataMap);
	    var depthSegment = unsafeGet("depthSegment", configDataMap);
	    var vertices = createEmpty(/* () */0);
	    var indices = createEmpty(/* () */0);
	    var faceAxes = /* array */[
	      /* int array */[
	        0,
	        1,
	        3
	      ],
	      /* int array */[
	        4,
	        5,
	        7
	      ],
	      /* int array */[
	        3,
	        2,
	        6
	      ],
	      /* int array */[
	        1,
	        0,
	        4
	      ],
	      /* int array */[
	        1,
	        4,
	        2
	      ],
	      /* int array */[
	        5,
	        0,
	        6
	      ]
	    ];
	    var corners = /* array */[
	      /* tuple */[
	        -width,
	        -height,
	        depth
	      ],
	      /* tuple */[
	        width,
	        -height,
	        depth
	      ],
	      /* tuple */[
	        width,
	        height,
	        depth
	      ],
	      /* tuple */[
	        -width,
	        height,
	        depth
	      ],
	      /* tuple */[
	        width,
	        -height,
	        -depth
	      ],
	      /* tuple */[
	        -width,
	        -height,
	        -depth
	      ],
	      /* tuple */[
	        -width,
	        height,
	        -depth
	      ],
	      /* tuple */[
	        width,
	        height,
	        -depth
	      ]
	    ];
	    var _generateFace = function (side, uSegment, vSegment) {
	      var offset = vertices.length / 3 | 0;
	      for(var i = 0; i <= uSegment; ++i){
	        for(var j = 0; j <= vSegment; ++j){
	          var temp1 = lerp(caml_array_get(corners, caml_array_get(caml_array_get(faceAxes, side), 0)), caml_array_get(corners, caml_array_get(caml_array_get(faceAxes, side), 1)), i / uSegment);
	          var temp2 = lerp(caml_array_get(corners, caml_array_get(caml_array_get(faceAxes, side), 0)), caml_array_get(corners, caml_array_get(caml_array_get(faceAxes, side), 2)), j / vSegment);
	          var temp3 = sub$1(/* Float */0, temp2, caml_array_get(corners, caml_array_get(caml_array_get(faceAxes, side), 0)));
	          var match = add$1(/* Float */0, temp1, temp3);
	          vertices.push(match[0], match[1], match[2]);
	          if (i < uSegment && j < vSegment) {
	            indices.push((offset + j | 0) + imul(i, uSegment + 1 | 0) | 0, (offset + j | 0) + imul(i + 1 | 0, uSegment + 1 | 0) | 0, ((offset + j | 0) + imul(i, uSegment + 1 | 0) | 0) + 1 | 0, (offset + j | 0) + imul(i + 1 | 0, uSegment + 1 | 0) | 0, ((offset + j | 0) + imul(i + 1 | 0, uSegment + 1 | 0) | 0) + 1 | 0, ((offset + j | 0) + imul(i, uSegment + 1 | 0) | 0) + 1 | 0);
	          }
	          
	        }
	      }
	      return /* () */0;
	    };
	    _generateFace(0, widthSegment | 0, heightSegment | 0);
	    _generateFace(1, widthSegment | 0, heightSegment | 0);
	    _generateFace(2, widthSegment | 0, depthSegment | 0);
	    _generateFace(3, widthSegment | 0, depthSegment | 0);
	    _generateFace(4, depthSegment | 0, heightSegment | 0);
	    _generateFace(5, depthSegment | 0, heightSegment | 0);
	    return /* record */[
	            /* vertices */vertices,
	            /* indices */indices
	          ];
	  } else {
	    return throwMessage("configData should exist");
	  }
	}

	function create$16(state) {
	  var match = create$17(state);
	  var index = match[1];
	  var state$1 = match[0];
	  set$1(index, _computeData, getGeometryData(state$1)[/* computeDataFuncMap */3]);
	  return /* tuple */[
	          state$1,
	          index
	        ];
	}


	/* ArraySystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function setConfigData$1(geometry, configData, state) {
	  var configDataHashMap = set("depthSegment", getValueFromJsObj(configData.depthSegment, 1), set("heightSegment", getValueFromJsObj(configData.heightSegment, 1), set("widthSegment", getValueFromJsObj(configData.widthSegment, 1), set("depth", getValueFromJsObj(configData.depth, 10), set("height", getValueFromJsObj(configData.height, 10), set("width", getValueFromJsObj(configData.width, 10), createEmpty$1(/* () */0)))))));
	  set$1(geometry, configDataHashMap, getGeometryData(state)[/* configDataMap */4]);
	  return state;
	}


	/* HashMapSystem-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var setConfigData = setConfigData$1;

	var create$15 = create$16;


	/* BoxGeometryCreateCommon-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var createBoxGeometry$1 = create$15;

	function setBoxGeometryConfigData$1(geometry, configData, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(geometry, isAlive$11, state);
	        }));
	  return setConfigData(geometry, configData, state);
	}


	/* GeometrySystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getMeshRendererGameObject$1(meshRenderer, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(meshRenderer, isAlive$15, state);
	        }));
	  return getExn(getGameObject$10(meshRenderer, state));
	}

	var createMeshRenderer$1 = create$13;


	/* MeshRendererSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var createBasicMaterial$1 = create$14;


	/* BasicMaterialSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var createSourceInstance$1 = create$10;

	function createSourceInstanceObjectInstance$1(sourceInstance, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(sourceInstance, isAlive$13, state);
	        }));
	  return createInstance(sourceInstance, state);
	}

	function getSourceInstanceObjectInstanceArray$1(sourceInstance, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(sourceInstance, isAlive$13, state);
	        }));
	  return getObjectInstanceArray$2(sourceInstance, state);
	}

	function markSourceInstanceModelMatrixIsStatic$1(sourceInstance, isStatic, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(sourceInstance, isAlive$13, state);
	        }));
	  return markModelMatrixIsStatic(sourceInstance, +isStatic, state);
	}


	/* SourceInstanceSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var getGameTime$2 = getGameTime$1;

	var getFps$2 = getFps$1;


	/* TimeControllerSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function setCameraControllerPerspectiveCamera$1(cameraController, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(cameraController, isAlive$12, state);
	        }));
	  return setPerspectiveCamera(cameraController, state);
	}

	function getCameraControllerPMatrix$1(cameraController, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(cameraController, isAlive$12, state);
	        }));
	  return getPMatrix(cameraController, state);
	}

	function getCameraControllerGameObject$1(cameraController, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(cameraController, isAlive$12, state);
	        }));
	  return getExn(getGameObject$7(cameraController, state));
	}

	function getCameraControllerWorldToCameraMatrix$1(cameraController, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive(cameraController, isAlive$12, state);
	        }));
	  return getWorldToCameraMatrix(getTransformFromCameraController(cameraController, state), state);
	}

	var createCameraController$1 = create$8;


	/* GetComponentUtils-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	function getPerspectiveCameraFovy$1(cameraController, state) {
	  return getExn(getFovy(cameraController, getPerspectiveCameraData(state)));
	}

	function getPerspectiveCameraAspect$1(cameraController, state) {
	  return getExn(getAspect(cameraController, getPerspectiveCameraData(state)));
	}

	function getPerspectiveCameraNear$1(cameraController, state) {
	  return getExn(getNear(cameraController, getPerspectiveCameraData(state)));
	}

	function getPerspectiveCameraFar$1(cameraController, state) {
	  return getExn(getFar(cameraController, getPerspectiveCameraData(state)));
	}

	var setPerspectiveCameraFovy$1 = setFovy;

	var setPerspectiveCameraAspect$1 = setAspect;

	var setPerspectiveCameraNear$1 = setNear;

	var setPerspectiveCameraFar$1 = setFar;


	/* PerspectiveCameraSystem-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
	var getCameraControllerWorldToCameraMatrix = getCameraControllerWorldToCameraMatrix$1;

	var getCameraControllerGameObject = getCameraControllerGameObject$1;

	var getCameraControllerPMatrix = getCameraControllerPMatrix$1;

	var setCameraControllerPerspectiveCamera = setCameraControllerPerspectiveCamera$1;

	var createCameraController = createCameraController$1;

	var setPerspectiveCameraFar = setPerspectiveCameraFar$1;

	var getPerspectiveCameraFar = getPerspectiveCameraFar$1;

	var setPerspectiveCameraNear = setPerspectiveCameraNear$1;

	var getPerspectiveCameraNear = getPerspectiveCameraNear$1;

	var setPerspectiveCameraAspect = setPerspectiveCameraAspect$1;

	var getPerspectiveCameraAspect = getPerspectiveCameraAspect$1;

	var setPerspectiveCameraFovy = setPerspectiveCameraFovy$1;

	var getPerspectiveCameraFovy = getPerspectiveCameraFovy$1;

	var setBoxGeometryConfigData = setBoxGeometryConfigData$1;

	var createBoxGeometry = createBoxGeometry$1;

	var getGeometryGameObject = getGeometryGameObject$1;

	var getGeometryConfigData = getGeometryConfigData$1;

	var setGeometryIndices = setGeometryIndices$1;

	var getGeometryIndices = getGeometryIndices$1;

	var setGeometryVertices = setGeometryVertices$1;

	var getGeometryVertices = getGeometryVertices$1;

	var getGeometryDrawMode = getGeometryDrawMode$1;

	var markSourceInstanceModelMatrixIsStatic = markSourceInstanceModelMatrixIsStatic$1;

	var getSourceInstanceObjectInstanceArray = getSourceInstanceObjectInstanceArray$1;

	var createSourceInstanceObjectInstance = createSourceInstanceObjectInstance$1;

	var createSourceInstance = createSourceInstance$1;

	var createBasicMaterial = createBasicMaterial$1;

	var setMaterialColor = setMaterialColor$1;

	var getMaterialColor = getMaterialColor$1;

	var getMaterialGameObject = getMaterialGameObject$1;

	var getMeshRendererGameObject = getMeshRendererGameObject$1;

	var createMeshRenderer = createMeshRenderer$1;

	var setTransformPosition = setTransformPosition$1;

	var getTransformPosition = getTransformPosition$1;

	var setTransformLocalPosition = setTransformLocalPosition$1;

	var getTransformLocalPosition = getTransformLocalPosition$1;

	var getTransformChildren = getTransformChildren$1;

	var setTransformParent = setTransformParent$1;

	var getTransformParent = getTransformParent$1;

	var getTransformGameObject = getTransformGameObject$1;

	var createTransform = createTransform$1;

	var loopBody = loopBody$1;

	var initDirector = initDirector$1;

	var startDirector = startDirector$1;

	var setMainConfig = setMainConfig$1;

	var scheduleLoop = scheduleLoop$2;

	var setState = setState$2;

	var getState = getState$2;

	var getStateData = getStateData$1;

	var restoreState = restoreState$1;

	var deepCopyStateForRestore = deepCopyStateForRestore$37;

	var getFps = getFps$2;

	var getGameTime = getGameTime$2;

	var cloneGameObject = cloneGameObject$1;

	var batchDisposeGameObject = batchDisposeGameObject$1;

	var initGameObject = initGameObject$2;

	var disposeGameObject = disposeGameObject$1;

	var isGameObjectAlive = isGameObjectAlive$1;

	var disposeGameObjectObjectInstanceComponent = disposeGameObjectObjectInstanceComponent$1;

	var getGameObjectObjectInstanceComponent = getGameObjectObjectInstanceComponent$1;

	var addGameObjectObjectInstanceComponent = addGameObjectObjectInstanceComponent$1;

	var disposeGameObjectSourceInstanceComponent = disposeGameObjectSourceInstanceComponent$1;

	var hasGameObjectSourceInstanceComponent = hasGameObjectSourceInstanceComponent$1;

	var getGameObjectSourceInstanceComponent = getGameObjectSourceInstanceComponent$1;

	var addGameObjectSourceInstanceComponent = addGameObjectSourceInstanceComponent$1;

	var hasGameObjectGeometryComponent = hasGameObjectGeometryComponent$1;

	var getGameObjectGeometryComponent = getGameObjectGeometryComponent$1;

	var disposeGameObjectGeometryComponent = disposeGameObjectGeometryComponent$1;

	var addGameObjectGeometryComponent = addGameObjectGeometryComponent$1;

	var hasGameObjectMeshRendererComponent = hasGameObjectMeshRendererComponent$1;

	var getGameObjectMeshRendererComponent = getGameObjectMeshRendererComponent$1;

	var disposeGameObjectMeshRendererComponent = disposeGameObjectMeshRendererComponent$1;

	var addGameObjectMeshRendererComponent = addGameObjectMeshRendererComponent$1;

	var hasGameObjectMaterialComponent = hasGameObjectMaterialComponent$1;

	var getGameObjectMaterialComponent = getGameObjectMaterialComponent$1;

	var disposeGameObjectMaterialComponent = disposeGameObjectMaterialComponent$1;

	var addGameObjectMaterialComponent = addGameObjectMaterialComponent$1;

	var hasGameObjectCameraControllerComponent = hasGameObjectCameraControllerComponent$1;

	var getGameObjectCameraControllerComponent = getGameObjectCameraControllerComponent$1;

	var disposeGameObjectCameraControllerComponent = disposeGameObjectCameraControllerComponent$1;

	var addGameObjectCameraControllerComponent = addGameObjectCameraControllerComponent$1;

	var hasGameObjectTransformComponent = hasGameObjectTransformComponent$1;

	var getGameObjectTransformComponent = getGameObjectTransformComponent$1;

	var disposeGameObjectTransformComponent = disposeGameObjectTransformComponent$1;

	var addGameObjectTransformComponent = addGameObjectTransformComponent$1;

	var createGameObject = createGameObject$1;


	/* Main-Wonderjs Not a pure module */

	exports.getCameraControllerWorldToCameraMatrix = getCameraControllerWorldToCameraMatrix;
	exports.getCameraControllerGameObject = getCameraControllerGameObject;
	exports.getCameraControllerPMatrix = getCameraControllerPMatrix;
	exports.setCameraControllerPerspectiveCamera = setCameraControllerPerspectiveCamera;
	exports.createCameraController = createCameraController;
	exports.setPerspectiveCameraFar = setPerspectiveCameraFar;
	exports.getPerspectiveCameraFar = getPerspectiveCameraFar;
	exports.setPerspectiveCameraNear = setPerspectiveCameraNear;
	exports.getPerspectiveCameraNear = getPerspectiveCameraNear;
	exports.setPerspectiveCameraAspect = setPerspectiveCameraAspect;
	exports.getPerspectiveCameraAspect = getPerspectiveCameraAspect;
	exports.setPerspectiveCameraFovy = setPerspectiveCameraFovy;
	exports.getPerspectiveCameraFovy = getPerspectiveCameraFovy;
	exports.setBoxGeometryConfigData = setBoxGeometryConfigData;
	exports.createBoxGeometry = createBoxGeometry;
	exports.getGeometryGameObject = getGeometryGameObject;
	exports.getGeometryConfigData = getGeometryConfigData;
	exports.setGeometryIndices = setGeometryIndices;
	exports.getGeometryIndices = getGeometryIndices;
	exports.setGeometryVertices = setGeometryVertices;
	exports.getGeometryVertices = getGeometryVertices;
	exports.getGeometryDrawMode = getGeometryDrawMode;
	exports.markSourceInstanceModelMatrixIsStatic = markSourceInstanceModelMatrixIsStatic;
	exports.getSourceInstanceObjectInstanceArray = getSourceInstanceObjectInstanceArray;
	exports.createSourceInstanceObjectInstance = createSourceInstanceObjectInstance;
	exports.createSourceInstance = createSourceInstance;
	exports.createBasicMaterial = createBasicMaterial;
	exports.setMaterialColor = setMaterialColor;
	exports.getMaterialColor = getMaterialColor;
	exports.getMaterialGameObject = getMaterialGameObject;
	exports.getMeshRendererGameObject = getMeshRendererGameObject;
	exports.createMeshRenderer = createMeshRenderer;
	exports.setTransformPosition = setTransformPosition;
	exports.getTransformPosition = getTransformPosition;
	exports.setTransformLocalPosition = setTransformLocalPosition;
	exports.getTransformLocalPosition = getTransformLocalPosition;
	exports.getTransformChildren = getTransformChildren;
	exports.setTransformParent = setTransformParent;
	exports.getTransformParent = getTransformParent;
	exports.getTransformGameObject = getTransformGameObject;
	exports.createTransform = createTransform;
	exports.loopBody = loopBody;
	exports.initDirector = initDirector;
	exports.startDirector = startDirector;
	exports.setMainConfig = setMainConfig;
	exports.scheduleLoop = scheduleLoop;
	exports.setState = setState;
	exports.getState = getState;
	exports.getStateData = getStateData;
	exports.restoreState = restoreState;
	exports.deepCopyStateForRestore = deepCopyStateForRestore;
	exports.getFps = getFps;
	exports.getGameTime = getGameTime;
	exports.cloneGameObject = cloneGameObject;
	exports.batchDisposeGameObject = batchDisposeGameObject;
	exports.initGameObject = initGameObject;
	exports.disposeGameObject = disposeGameObject;
	exports.isGameObjectAlive = isGameObjectAlive;
	exports.disposeGameObjectObjectInstanceComponent = disposeGameObjectObjectInstanceComponent;
	exports.getGameObjectObjectInstanceComponent = getGameObjectObjectInstanceComponent;
	exports.addGameObjectObjectInstanceComponent = addGameObjectObjectInstanceComponent;
	exports.disposeGameObjectSourceInstanceComponent = disposeGameObjectSourceInstanceComponent;
	exports.hasGameObjectSourceInstanceComponent = hasGameObjectSourceInstanceComponent;
	exports.getGameObjectSourceInstanceComponent = getGameObjectSourceInstanceComponent;
	exports.addGameObjectSourceInstanceComponent = addGameObjectSourceInstanceComponent;
	exports.hasGameObjectGeometryComponent = hasGameObjectGeometryComponent;
	exports.getGameObjectGeometryComponent = getGameObjectGeometryComponent;
	exports.disposeGameObjectGeometryComponent = disposeGameObjectGeometryComponent;
	exports.addGameObjectGeometryComponent = addGameObjectGeometryComponent;
	exports.hasGameObjectMeshRendererComponent = hasGameObjectMeshRendererComponent;
	exports.getGameObjectMeshRendererComponent = getGameObjectMeshRendererComponent;
	exports.disposeGameObjectMeshRendererComponent = disposeGameObjectMeshRendererComponent;
	exports.addGameObjectMeshRendererComponent = addGameObjectMeshRendererComponent;
	exports.hasGameObjectMaterialComponent = hasGameObjectMaterialComponent;
	exports.getGameObjectMaterialComponent = getGameObjectMaterialComponent;
	exports.disposeGameObjectMaterialComponent = disposeGameObjectMaterialComponent;
	exports.addGameObjectMaterialComponent = addGameObjectMaterialComponent;
	exports.hasGameObjectCameraControllerComponent = hasGameObjectCameraControllerComponent;
	exports.getGameObjectCameraControllerComponent = getGameObjectCameraControllerComponent;
	exports.disposeGameObjectCameraControllerComponent = disposeGameObjectCameraControllerComponent;
	exports.addGameObjectCameraControllerComponent = addGameObjectCameraControllerComponent;
	exports.hasGameObjectTransformComponent = hasGameObjectTransformComponent;
	exports.getGameObjectTransformComponent = getGameObjectTransformComponent;
	exports.disposeGameObjectTransformComponent = disposeGameObjectTransformComponent;
	exports.addGameObjectTransformComponent = addGameObjectTransformComponent;
	exports.createGameObject = createGameObject;

	Object.defineProperty(exports, '__esModule', { value: true });

})));